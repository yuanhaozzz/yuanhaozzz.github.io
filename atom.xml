<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-07T09:32:27.372Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>渡丶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS: 伪类 focus-within</title>
    <link href="http://yoursite.com/2018/08/06/CSS-%E4%BC%AA%E7%B1%BB-focus-within/"/>
    <id>http://yoursite.com/2018/08/06/CSS-伪类-focus-within/</id>
    <published>2018-08-06T09:44:53.000Z</published>
    <updated>2018-08-07T09:32:27.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>css确实很强大，能够实现一些js也能完成的特殊功能<br>比如现在要说的表单元素 focus-within属性，这也是我从前端大全公众号里面看到的，大家可以关注下，干货真的很多<br><a id="more"></a><br><a href="https://mp.weixin.qq.com/s/q-OaYqJfm08803-E5PJOhA" target="_blank" rel="noopener">传送门！！！</a></p><h3 id="正主-focus-within"><a href="#正主-focus-within" class="headerlink" title="正主 focus-within"></a>正主 focus-within</h3><p>在上面的连接中，已经详细的介绍了，我就不重复他的话了 我只做一些自己的理解</p><p>首先，该元素只适用于 <strong>表单元素</strong> ,他跟js的冒泡原理一样，一级一级往上冒，也就说 你可以通过这个原理来进行操作同级或者父级元素样式，从而来实现css的各种特效/样式</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;css确实很强大，能够实现一些js也能完成的特殊功能&lt;br&gt;比如现在要说的表单元素 focus-within属性，这也是我从前端大全公众号里面看到的，大家可以关注下，干货真的很多&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滚动顶部或底部出现白色边缘</title>
    <link href="http://yoursite.com/2018/07/31/%E6%BB%9A%E5%8A%A8%E9%A1%B6%E9%83%A8%E6%88%96%E5%BA%95%E9%83%A8%E5%87%BA%E7%8E%B0%E7%99%BD%E8%89%B2%E8%BE%B9%E7%BC%98/"/>
    <id>http://yoursite.com/2018/07/31/滚动顶部或底部出现白色边缘/</id>
    <published>2018-07-31T07:40:05.000Z</published>
    <updated>2018-08-06T09:43:29.284Z</updated>
    
    <content type="html"><![CDATA[<p>###前言</p><p>这是困扰我很久的一个问题<br><a id="more"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>大家都知道，在ios下fixed定位失效问题，为了解决这一问题，必须自己制作滚动条，也就是说比如头部需要固定，把滚动条给内容就好，实际则是内容滚动</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>height:100%<br>overflow-y: scroll<br>给其元素添加这个属性即可</p><p>###彩蛋</p><p>因为ios不支持fixed定位，但如果中间有吸顶效果怎么办？</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>按照一般思路 监听滚动时间scrollTop，当scrollTop &gt; el.offsetTop时 改为fixed定位，否则为absolute</p><p>但是在ios下,滚动事件并不是实时的, 手指滚动 =&gt; 滚动开始 =&gt; 滚动停止 =&gt; 触发事件，所以这个也不靠谱</p><p>position: -webkit-sticky<br>position:sticky     神器属性 需要写兼容</p><p>一定注意，滚动条一定设置overflow-y: scroll 属性</p><p>该粘性定位在滚动时正常滚动，但当滚动条超过时，自动变为固定定位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###前言&lt;/p&gt;
&lt;p&gt;这是困扰我很久的一个问题&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-对象扩展</title>
    <link href="http://yoursite.com/2018/07/09/ES6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/09/ES6-对象扩展/</id>
    <published>2018-07-09T11:45:02.000Z</published>
    <updated>2018-07-31T08:33:27.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a><br><a id="more"></a></p><h3 id="属性的简介表示法"><a href="#属性的简介表示法" class="headerlink" title="属性的简介表示法"></a>属性的简介表示法</h3><p>ES6允许直接写入变量名 与 函数名 来作为对象的属性 和 方法  这样使语法更加简介</p><pre><code>let x = 40function y () {    alert(1)}let obj = {x, y}console.log(obj)    // {x: 40, y: function}obj.y()             // 1function fn(x, y) {    return {x, y}}// 等同于function fn(x, y) {    return {x: x, y: y}}</code></pre><p>函数也同样<br>    let age = 18</p><pre><code>const Person = {    name: &apos;张三&apos;,    age,    // age: age    fn () {         // fn: function ....        console.log(this.age)    }}</code></pre><h3 id="Objuct-is-弥补-的不足-自动转换为数组类型-NAN都不相等-判断是否相等"><a href="#Objuct-is-弥补-的不足-自动转换为数组类型-NAN都不相等-判断是否相等" class="headerlink" title="Objuct.is() 弥补 == === 的不足  == 自动转换为数组类型  ===  NAN都不相等     判断是否相等"></a>Objuct.is() 弥补 == === 的不足  == 自动转换为数组类型  ===  NAN都不相等     判断是否相等</h3><pre><code>console.log(Object.is(1, &apos;1&apos;))         // false     // 同样是严格模式console.log(Object.is(1, 1))         // true console.log(Object.is({}, {}))         // false     let obj = {    name: [        {            c: &apos;aa&apos;        }    ],    b: 12}let obj1 = [...obj.name]console.log(obj.name == obj1)      // false</code></pre><h3 id="Object-assign-合并对象"><a href="#Object-assign-合并对象" class="headerlink" title="Object.assign()     合并对象"></a>Object.assign()     合并对象</h3><pre><code>// 注：assign 是浅拷贝let a = {a: &apos;a&apos;}let b = {b: &apos;b&apos;}           let obj = Object.assign(a, b)    // {a: &apos;a&apos;, b: &apos;b&apos;}// 如果有相同的键值，则后面的值会覆盖前面的let c = {b: &apos;c&apos;}   let obj = Object.assign(a, b, c)          // {a: &apos;a&apos;, b: &apos;c&apos;}let obj = Object.assign({}, a, b, c)console.log(a) 第一个参数为目标对象 指定为一个空,这样不会破坏原对象，同时，他只会拷贝原对象自身属性 ， 用处很多  不管是给对象新增属性 还是 方法 都很方便对象同样具有扩展运算符let obj = {a: 1, b: 2}let obj1 = {...obj}console.log(obj1)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructuring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript 6入门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-数组扩展</title>
    <link href="http://yoursite.com/2018/07/06/ES6-%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/06/ES6-数组扩展/</id>
    <published>2018-07-06T08:46:53.000Z</published>
    <updated>2018-07-09T11:46:40.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a><br><a id="more"></a></p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>基本用法</p><pre><code>扩展用算符是三个点，好比rest函数参数一样let arr = [1, 2, 3]console.log(...arr)     1 2 3console.log([...arr])     1 2 3</code></pre><p>使用扩展运算符传参</p><pre><code>function num(x, y, b) {     return x + y + b}let arr = [1,2,3]console.log(num(...arr))     // 6</code></pre><p>使用max求最大值</p><pre><code>console.log(Math.max(1,5,4,1,9,8))     // 9// 使用数组需要转console.log(Math.max([1, 5, 6, 4]))     // NAN// 使用扩展运算符更加简洁，方便console.log(Math.max(...[1,5,4,1,9,8]))     // 9</code></pre><p>push方法    数组的合并</p><pre><code>let [x, y] = [[1, 2, 3], [4, 5, 6]] 方法一console.log(x.concat(y))    // [1, 2, 3, 4, 5, 6]方法二x.push(...y)console.log(x)              // [1, 2, 3, 4, 5, 6]</code></pre><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><ol><li><p>复制数组</p><p> let arr1 = [1, 2];<br> let arr2 = arr1<br> arr2[0] = 2<br> console.log(arr1)   // [2, 2]<br> 上面代码中,只是多了一个指针，但是在内存当中都指向同一块空间，所以任意改变都会修改原数组</p><p> let arr1 = [1, 2];<br> arr2[0] = 2<br> // ES5解决<br> // let arr2 = arr1.concat()     // [1, 2]<br> // ES6解决<br> let arr2 = […arr1]            // [1, 2]<br> // Array.from()<br> let arr2 = Array.from(arr1)     // [1, 2]<br> arr2[0] = 2</p></li></ol><p>上述方法都可实现深拷贝</p><p>配合解构</p><pre><code>const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]let arr5 = [[1, 5], [2, 9]]...arr5     // [1, 5] [2, 9]</code></pre><h3 id="Array-from-用于将两种类数组转换为真正的数组"><a href="#Array-from-用于将两种类数组转换为真正的数组" class="headerlink" title="Array.from()    用于将两种类数组转换为真正的数组"></a>Array.from()    用于将两种类数组转换为真正的数组</h3><ol><li>有length的类数组     例如 document.getElementByTagName(‘div’)</li><li>可迭代的对象</li></ol><pre><code>let arrayLike = {&apos;0&apos;: &apos;a&apos;,&apos;1&apos;: &apos;b&apos;,&apos;2&apos;: &apos;c&apos;,length: 3}let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</code></pre><p>第二参数</p><pre><code>// Array.from  接受第二个参数  类似于 maplet arr = [1, 2, 3]console.log(Array.from(arr, (item) =&gt; item * item))     // [1, 4, 9]</code></pre><h3 id="Array-isArray-用于判断是否为一个真正的数组"><a href="#Array-isArray-用于判断是否为一个真正的数组" class="headerlink" title="Array.isArray()     用于判断是否为一个真正的数组"></a>Array.isArray()     用于判断是否为一个真正的数组</h3><pre><code>function isArray () {    return arguments}let fn = isArray(1, 5)console.log(Array.isArray(fn))                  // falseconsole.log(Array.isArray(Array.from(fn)))      // true</code></pre><h3 id="Array-of-用来创建数组并给其指定值"><a href="#Array-of-用来创建数组并给其指定值" class="headerlink" title="Array.of()  用来创建数组并给其指定值"></a>Array.of()  用来创建数组并给其指定值</h3><pre><code>一般声明数组console.log(new Array(5))      // [, , , ,]console.log(new Array(5, 2))             // [5, 2]console.log(new Array())                 // []console.log(Array.of(5))      // [5]console.log(Array.of(5, 2))             // [5, 2]console.log(new Array())                 // []使用其好处在于都进行了一个统一</code></pre><h3 id="Array-find-找到数组中包含某一项"><a href="#Array-find-找到数组中包含某一项" class="headerlink" title="Array.find() 找到数组中包含某一项"></a>Array.find() 找到数组中包含某一项</h3><p>[].findIndex()  用法与find一样   返回查找数组下标   这两个方法弥补了indexOf 方法的不足  都可以发现NAN</p><pre><code>console.log([1,8,5,6,9].find(x =&gt; x === 5))      // 5let arr = [    {        name: &apos;a&apos;    },    {        name: &apos;b&apos;    }]// 可接受三个参数  每一项, 下标, 原数组console.log(arr.find((x, index, arr) =&gt; {    console.log(index)    console.log(arr)    return x.name === &apos;b&apos;}))</code></pre><p>find方法只会返回一次，如果为空返回undefined</p><h3 id="Array-fill-装填，给数组指定默认值"><a href="#Array-fill-装填，给数组指定默认值" class="headerlink" title="Array.fill()    装填，给数组指定默认值"></a>Array.fill()    装填，给数组指定默认值</h3><pre><code>let arr = new Array(3).fill(&apos;&apos;)     // [&apos;&apos;, &apos;&apos;, &apos;&apos;]let arr = new Array(3).fill(5)     // [5, 5, 5]</code></pre><p>它有三个参数  参数 开始位置 结束位置</p><pre><code>console.log([1, 8, 6, 4].fill(2, 1, 2))     // [1, 2, 6, 4]console.log([1, 8, 6, 4].fill(2, 1, 8))     // [1, 2, 2, 2]</code></pre><h3 id="Array-entries-返回数组的键值"><a href="#Array-entries-返回数组的键值" class="headerlink" title="Array.entries()     返回数组的键值"></a>Array.entries()     返回数组的键值</h3><pre><code>let arr = [1, 2, 3, 5]for(let [index, item] of arr.entries()) {    console.log(&apos;value&apos; + item)    console.log(&apos;index&apos; + index)}使用了解构的方式进行赋值    [0, 1] [1, 2] [2, 3] [3, 5]</code></pre><h3 id="Array-keys-返回数组的键"><a href="#Array-keys-返回数组的键" class="headerlink" title="Array.keys()     返回数组的键"></a>Array.keys()     返回数组的键</h3><pre><code>let arr = [1, 2, 3, 8]for(let a of arr.keys()) {    console.log(&apos;index             &apos; + a)   // 下标}</code></pre><h3 id="includes-查找数组中是否包含某一项"><a href="#includes-查找数组中是否包含某一项" class="headerlink" title="includes()  查找数组中是否包含某一项"></a>includes()  查找数组中是否包含某一项</h3><pre><code>console.log([1, 2, 3].includes(2))      //true// 第二个参数 从该下标处开始查  如果大于当前数组长度 则 为默认值0  负数代表查找最后一个console.log([1, 2, 3].includes(2, 2))      //falseconsole.log([1, 2, 3].includes(3, -1))      //false</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructuring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript 6入门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-函数扩展</title>
    <link href="http://yoursite.com/2018/07/04/ES6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/04/ES6-函数扩展/</id>
    <published>2018-07-04T08:29:23.000Z</published>
    <updated>2018-07-06T08:45:49.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加油！<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><pre><code>function fn (x = 2) {    console.log(x)}fn(10)  // 10fn()    // 2</code></pre><p>无法使用Let 和 const再次进行声明，他们是唯一的</p><pre><code>function fn (x = 2) {    let x = 1    console.log(x)}fn(10)// 报错</code></pre><p>同样可是使用解构的方式</p><pre><code>function foo({x, y}) {    console.log(x, y());}foo({x: 1, y: () =&gt; 8})// x 1// y 8</code></pre><p>也可以指定默认值</p><pre><code>function foo({x = 50, y}) {    console.log(x, y());}foo({y: () =&gt; 8})// x 50// y 8</code></pre><h3 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h3><p>基本用法</p><pre><code>function fn(...arr) {    let sum = 0    arr.forEach(item =&gt; {        sum += item    })    return sum}console.log(fn(1, 2, 3))    // 6</code></pre><p>转换数组的方式</p><pre><code>// 方法1 function fn() {    return Array.prototype.slice.call(arguments)}// 方法2 rest function fn1(...arr) {    return arr}// 方法3 Array.from()function fn2() {    console.log(Array.from(arguments))}</code></pre><p>注意 rest后面不能再跟参数，否则会报错</p><pre><code>function fn(one, ...arr, num) {    // ...}fn(1,5,6,2)// 报错</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数使用为最多，他不仅语法简洁，降低代码量，同时更具有可读性</p><pre><code>let obj = {name: &apos;aa&apos;}let f = item =&gt; item.nameconsole.log(f(obj))     // aa</code></pre><p>如果没有参数 或者 有多个参数 用圆括号</p><pre><code>let a = () =&gt; 5let b = (num1, num2) =&gt; num1 + num2// 等同于let a = function () {    return 5}let b = function (num1, num2) {    return num1 + num2}</code></pre><p>只有代码为1行时不用写return </p><pre><code>let a = (item) =&gt; {    if (item.id === 1) {        return item    }}</code></pre><p>配合解构</p><pre><code>let obj = {    a: function () {        alert(88)    },    b: 10,    c: 16}let fn = ({a, b}) =&gt; a()    fn(obj) // 88let fn = ({c, b = 7}) =&gt; b + c  fn(obj) // 26</code></pre><p>默认值</p><pre><code>let obj = {    a: function () {        alert(88)    },    c: 16}let fn = ({c, b = 7}) =&gt; b + c  fn(obj)     // 23</code></pre><p>来看这个例子</p><pre><code>function Timer() {    this.s1 = 0;    this.s2 = 0;    // 箭头函数    setInterval(() =&gt; this.s1++, 1000);    // 普通函数    setInterval(function () {        this.s2++;        // alert(this.s2)    }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);   // 3setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);   // 0// 使用箭头函数 this会指向定义时的对象，所以s1会在3秒调用3次 为3  s2 的this指向了window的s2 并不存在 3秒内都是window的s2 在++ ，相加为NAN  但是是打印的当前构造函数内的s2，所以值为0</code></pre><p>所以下面为被编译的ES5</p><pre><code>let a = () =&gt; {    setTimeout(() =&gt; {        console.log(this.id)    }, 2000);}let a = function () {    var _this = this    setTimeout(() =&gt; {        console.log(_this.id)    }, 2000);}</code></pre><h3 id="箭头函数总结"><a href="#箭头函数总结" class="headerlink" title="箭头函数总结"></a>箭头函数总结</h3><pre><code>1. 代码简洁，更具有可读性2. this指向定义时的对象，并不是调用时的3. 因为本身并没有this,无法作为构造函数，无法使用New4. 没有arguments对象，不过可以使用rest   ...arr</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加油！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-字符串扩展</title>
    <link href="http://yoursite.com/2018/07/04/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/04/ES6-字符串扩展/</id>
    <published>2018-07-04T06:23:21.000Z</published>
    <updated>2018-07-04T08:47:17.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加油！<br><a id="more"></a></p><p>遵循二八，只写常用的</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>在ES5中 查找字符串是否存在使用indexOf 大于-1则存在，ES6出了个方法，includes,改方法返回boolean</p><pre><code>let str = &apos;卫栖梧dqweqwe4152&apos;console.log(str.includes(&apos;5&apos;))      // trueconsole.log(str.includes(&apos;10&apos;))      // falseconsole.log(str.includes(&apos;dqwe&apos;))      // true</code></pre><p>startsWith 第一个是否为某一项<br>endsWith 最后一个是否为某一项</p><pre><code>let str = &apos;卫栖梧dqweqwe4152&apos;console.log(str.startsWith(&apos;5&apos;))    // falseconsole.log(str.endsWith(&apos;2&apos;))      // true</code></pre><p>repeat 重复字符串</p><pre><code>// console.log(&apos;aaa&apos;.repeat(8))         // aaaaaaaaaaaaaaaaaaaaaaaa</code></pre><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>先看常规拼接字符串</p><pre><code>let a = &apos;谁最帅&apos;let b = &apos;当然是我&apos;console.log(&apos;现在&apos; + a + &apos;,&apos; + b + &apos;啦&apos;)    //现在谁最帅,当然是我啦</code></pre><p>ES6 字符串模板<br>    console.log(<code>现在${a},${b}啦</code>)      //现在谁最帅,当然是我啦</p><p>这样的写法更具有可读性，更加简洁，同时字符串模板支持简单的运算，可写函数返回，还支持隔行</p><pre><code>let a = &apos;拼接&apos;let b = &apos;字符串&apos;function name () {    return &apos;我是函数&apos;}let c = `我在${a}${b}    ${name()}`console.log(c)// 我在拼接字符串        我是函数</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加油！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-解构赋值</title>
    <link href="http://yoursite.com/2018/06/27/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2018/06/27/ES6-解构赋值/</id>
    <published>2018-06-27T11:49:59.000Z</published>
    <updated>2018-07-04T08:09:01.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>只想每天学习新的总结那么一点，不想原地踏步<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>解构分为数组解构、对象解构、字符串解构、函数参数解构,还有些不常用的，就不说了</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>通常我们进行赋值</p><pre><code>let a = &apos;a&apos;let b = &apos;b&apos;let c = &apos;c&apos;</code></pre><p>ES6提供数组解构为</p><pre><code>let [a, b, c] = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]a // &apos;a&apos;b // &apos;b&apos;c // &apos;c&apos;</code></pre><p>从上述可以看得出来，数组组件主要针对位置来进行赋值</p><p>也可写成这样<br>    let [a, [b, c]] = [10, [20, 30]]<br>    a // 10<br>    b // 20<br>    c // 30</p><p>如果对应位置没有对应值，则为undefined<br>    let [a, [b, c]] = [10, [, 30]]<br>    a // 10<br>    b // undefined<br>    c // 30</p><p>也可初始化值</p><pre><code>let [a=5, [b=3, c]] = [10, [, 30]]a // 10b // 3c // 30</code></pre><p>// 需要注意！只有当等于undefined时才会被赋值默认值，注意是全等，严格模式</p><pre><code>let [a=5, [b=3, c]] = [10, [null, 30]]a // 10b // nullc // 30</code></pre><p>赋值必须是可迭代的(iterator)</p><pre><code>let [a=5,b] = 1// 报错</code></pre><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>这样写会抛出错误<br>    let {a:10,b:10} = {a:20,b: 40}</p><p>原因，对象解构与数组解构不同，数组解构是通过对应位置，而对象解构则通过 等号 左边的键 去查找 右侧的键值，在找到后，赋值给右侧的值</p><pre><code>let {a: b,c: d} = {a: 50, c: 90}a //undefinedb // 50c // undefinedd // 90</code></pre><p>看到这应该明白了  也就是收  通过a 到 右边去找到对应的值，然后从新赋值给b  这就是区别</p><p>设定默认值</p><pre><code>let {a: b=10,c: d=4} = {a: undefined, c: undefined}b // 10d // 4</code></pre><h3 id="函数参数解构"><a href="#函数参数解构" class="headerlink" title="函数参数解构"></a>函数参数解构</h3><pre><code>function a () {    alert(&apos;a&apos;)}function b () {    alert(&apos;b&apos;)}function move ([a, b]) {    a()}move([a, b])</code></pre><p>总之,把数组解构 和 对象解构 理解了 其他都差不多</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;只想每天学习新的总结那么一点，不想原地踏步&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue，公共tab跳转不同路由页面样式切换</title>
    <link href="http://yoursite.com/2018/06/08/Vue%EF%BC%8C%E5%85%AC%E5%85%B1tab%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E8%B7%AF%E7%94%B1%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/06/08/Vue，公共tab跳转不同路由页面样式切换/</id>
    <published>2018-06-08T08:53:27.000Z</published>
    <updated>2018-06-08T11:35:27.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>先有一个公共tab组件用来分别跳转不同路由的页面</p><p>例<br>    a 公共组件<br>    b 点击跳转页面<br>    c 点击跳转页面</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>两种方法解决选中样式问题</p><ol><li>router-link标签 （推荐）<br><router-link to="/a" active-class="active"><br><router-link to="/b" active-class="active"></router-link></router-link></li></ol><p>active为选中的样式</p><ol start="2"><li>通过路由当前参数来进行判断</li></ol><p>data () {<br>    return {<br>        active: this.$route.query.index || 0<br>    }<br>}</p><p>在跳转时传递不同参数  选项卡通过当前active来进行判断，实现样式的切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;p&gt;先有一个公共tab组件用来分别跳转不同路由的页面&lt;/p&gt;
&lt;p&gt;例&lt;br&gt;    a 公共组件&lt;br&gt;    b 点击跳转页面&lt;br&gt;   
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>v-html</title>
    <link href="http://yoursite.com/2018/06/07/v-html/"/>
    <id>http://yoursite.com/2018/06/07/v-html/</id>
    <published>2018-06-07T07:50:58.000Z</published>
    <updated>2018-06-08T08:51:31.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>v-html 渲染出来的标签无法修改样式</p><p>结构</p><pre><code>&lt;div class=&quot;wrap&quot;&gt;    &lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>解决</p><pre><code>.wrap &gt;&gt;&gt;div{    //.....}.wrap &gt;&gt;&gt;span{    //.....}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小技巧&quot;&gt;&lt;a href=&quot;#小技巧&quot; class=&quot;headerlink&quot; title=&quot;小技巧&quot;&gt;&lt;/a&gt;小技巧&lt;/h3&gt;&lt;p&gt;v-html 渲染出来的标签无法修改样式&lt;/p&gt;
&lt;p&gt;结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="http://yoursite.com/2018/05/25/vuex/"/>
    <id>http://yoursite.com/2018/05/25/vuex/</id>
    <published>2018-05-25T11:45:26.000Z</published>
    <updated>2018-06-07T07:49:54.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vuex,个人理解为一个提供全局公用的属性及方法，是中大型开发项目架构中不可缺少的一部分，他的设计及使用都很方便，便于协同开发。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install --save-dev vuex</code></pre><p>安装至package.json中开发依赖</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>main.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import store from &apos;./store/index&apos;Vue.use(Vuex)               // 全局配置new Vue({    el: &apos;#app&apos;,    router,    store,                  // 导入全局    render: h =&gt; h(App)})</code></pre><p>store/index.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)               // 全局配置let store = {    state: {        ....    },    getters: {        ....    },    mutations: {        ....    },    actions: {        ....    }}//导出storeexport default store</code></pre><p>以上是store的基本配置</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>存储数据的，任何属性的定义都在里</p><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以理解为Vue的计算属性，假设有这样一个需求  需要让你过滤出小于25的数</p><pre><code>let sotre = {    state: {        data: [10, 50, 10, 40]    }}当然聪明你的肯定在组件中轻易的就可以写出来，但是如果换一个页面的话 是不是还要在写一遍？如果10， 20个的话 是不是就吐啦？？，所以getters就来解决这种问题</code></pre><p>store/index.js</p><pre><code>let sotre = {    state: {        data: [10, 50, 10, 40]    },    getters: {        filterData (state) {            return state.data.filter(item =&gt; item &lt; 25)        }    }}</code></pre><p>index.vue</p><pre><code>mounted () {    // 获取已过滤出的数据    let data = this.$store.getters.filterData}</code></pre><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>想要修改state 中的数据 ，只能mutations来进行修改，并且它是同步的，稍后会讲到action（异步），这种模式能够更加清晰的知道你的数据是什么来进行改变的，具有可读性和可维护性</p><p>store/index.js</p><pre><code>state: {    name: &apos;张三&apos;},getters: {    filterData (state) {        return state.data.filter(item =&gt; item &lt; 25)    }},mutations: {    changeName1 (state) {        state.name = &apos;李四&apos;    },    changeName2 (state, people) {        state.name = people.name    }}</code></pre><p>index.vue</p><pre><code>// 调用1html{{ this.$store.state.name }}  // 李四mounted () {    this.$store.commit(&apos;changeData&apos;)}// 调用2html{{ this.$store.state.name }}  // aamounted () {    // 传值方式1    this.$store.commit(&apos;changeData&apos;, {        name: &apos;aa&apos;    })    // 传值方式2    this.$store.commit({        type: &apos;changeData&apos;,        name: &apos;aa&apos;    })}</code></pre><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>前面说到了 mutations 是使用同步来进行解决的，异步的话使用action来处理，为什么呢？ 首先，得按照人家的规矩的来不是？ 其次，还是因为追踪数据，如果mutations使用了异步，无法追踪到数据改变的纪录，同时有时会导致错误，无法进行赋值，前面说了只能通过mutations来进行改变，所以action所做的就是调用mutations内的函数，通过实参传递过去。</p><p>store/index.js</p><pre><code>state: {    arr: &apos;张三&apos;,    userInfo: []},getters: {    filterData (state) {        return state.data.filter(item =&gt; item &lt; 25)    },    userInfo: state =&gt; state.userInfo},mutations: {    changeArr (state) {        state.arr = data      },    changeArr1 (state, data) {        state.arr = data.data    }},action: {    asynChangeName ({commit}) {         // es6函数参数解构        commit(&apos;changeName&apos;)            // 基本调用    },    asynChangeName1 ({commit}) {         // es6函数参数解构        let data = [            {                name: &apos;加油&apos;,                age: 10            }, {                name: &apos;你是&apos;,                age: 15            }, {                name: &apos;最棒的&apos;,                age: 20            },        ]        setTimeOut(() =&gt; {            commit(&apos;changeName&apos;, data)      // 异步通过这种方式来进行赋值        }, 200)    },    asynChangeName2 ({commit}) {        new Promise((resolve, rejuct) =&gt; {            let random = Math.random()            if (random &gt; 0.5) {                resolve(random)            } else {                rejuct(&apos;小于0.5哦&apos;)            }        })    },    getUserInfo () {    }}</code></pre><p>index.vue</p><pre><code>mounted () {    let num = this.$store.dispatch(&apos;asynChangeName2&apos;)    num.then((resolve) =&gt; {        alert(resolve)    })}</code></pre><p>main.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import Router from &quot;vue-router&quot;import store from &apos;./store/index&apos;Vue.use(Vuex)               // 全局配置Vue.use(Router)             // 全局路由Router.beforeEach((to, from, next) =&gt; {    if (store.state.userInfo.length === 0) {        next({            path: &apos;/&apos;        })    }    next()})new Vue({    el: &apos;#app&apos;,    router,    store,                  // 导入全局    render: h =&gt; h(App)})一个简单的路由守卫拦截的登录功能，同样具有拦截效果的是axios，具体在后面我会更新</code></pre><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>当你的项目越来越庞大，store会变的臃肿，所以你需要继续把它拆分出来，更具有可维护性</p><p>store/index.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import User from &apos;./store/common/user.js&apos;import Other from &apos;./store/common/other.js&apos;Vue.use(Vuex)export default new Vuex.Store({    modules: {        User,        Other    }})</code></pre><p>store/common/user.js</p><pre><code>let User = {    state: {        ...    },    mutations: {    }}export default User</code></pre><p>store/common/other.js</p><pre><code>let Other = {    state: {        ...    },    mutations: {    }}export default Other</code></pre><p>以上是个人理解Vuex，让我们继续努力加油吧！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vuex,个人理解为一个提供全局公用的属性及方法，是中大型开发项目架构中不可缺少的一部分，他的设计及使用都很方便，便于协同开发。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gulp</title>
    <link href="http://yoursite.com/2018/05/21/gulp/"/>
    <id>http://yoursite.com/2018/05/21/gulp/</id>
    <published>2018-05-21T11:19:16.000Z</published>
    <updated>2018-05-25T11:44:42.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在被大老大一顿嘲讽后，恶补了一下gulp,看了看  真的很简单呀<br>    gulp拥有简洁的API，使用者能够轻易上手，Gulp是一个自动化构建工具，具有强大的插件，只要搭配合适，能够大大提高我们工作中开发的效率。gulp更加强调的是开发流程，通过taskAPI可以定义符合自己的流程。<br>    webpack主要是模块化的规范，更加强调模块化，把各种文件看成模块，用过loader,最终打包为css/js/html/图片等</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">前端构建工具gulpjs的使用介绍及技巧 - 无双 - 博客园</a></p><h3 id="gulp-工作模式"><a href="#gulp-工作模式" class="headerlink" title="gulp 工作模式"></a>gulp 工作模式</h3><p>gulp是基于nodejs的stream流的概念，通过pipe()来导入到你想要让他去的地方，是一个抽象的概念，比如gulp.src获取到相关内容，通过.pipe导入到插件中，在通过插件处理后，在通过pipe导入，通过gulp.dest来指定到相应位置</p><h3 id="四大API"><a href="#四大API" class="headerlink" title="四大API"></a>四大API</h3><p><strong>一 gulp.src(glob, [, option])</strong><br>    该方法主要获取到你的文件源，通过这个路径来找到对应的文件</p><ol><li>glob类似于正则表达式，主要通过这个来找到文件</li><li>option 可选参数，通常不需要用到</li></ol><p>主要讲讲glob</p><pre><code>*                   // 匹配0个或多个字符，但不会匹配到路径分隔符**                  // 匹配所有字符，包括路径分隔符?                   // 匹配文件中的一个字符，不包含路径分隔符[...]               // 匹配方括号中的所有路径，如果出现^或者!，则匹配时不会去找相应文件</code></pre><p>例子：</p><pre><code>*                   // 能匹配a.js/b.css/d.html/aa    但不包含b/a.js*.*                 // 能匹配.后缀名所有的文件**                  // 能匹配所有文件，包含b/a.js c/d.css*/*/*.*             // 能匹配a/b/a.js / c/d/b.css[&apos;*/abc/*.js&apos;]      // 匹配c/abc/e.js / v/abc/ss.js[&apos;!c/abc/*.js&apos;, &apos;c/abc/*.css&apos;]     // 不会匹配c/abc/下的所有js</code></pre><p><strong>二 gulp.dest(path, [, option])</strong><br>该方法主要把经过<strong>插件处理</strong> 或 <strong>gulp.src命令</strong>中的stream流写入到指定的文件路径</p><ol><li>path指定路径</li><li>option 可选参数，通常不需要用到</li></ol><p>例子：<br>    gulp.task(‘default’, function () {<br>        gulp.src(‘src/css/*.css’)<br>            .pipe(gulp.dest(‘dist/css’))<br>    })</p><p>task命令稍后会讲，以上功能只是一个简单的复制功能，就是找到src/css下所有css文件，通过dest命令写入dist/css文件中</p><p><strong>三 gulp.task(name, [, deps], fn)</strong><br>task方法用于定义命令</p><ol><li>name为命令的名称</li><li>deps依赖任务的队列，如果你对执行顺序有要求，以数组的方式依次写入顺序即可</li><li>fn业务逻辑</li></ol><p>创建一个依赖队列的任务执行<br>gulp.task(‘test’, [‘a’, ‘b’, ‘c’, ‘d’], function () {<br>    // …..<br>})</p><p>这个命令也没啥好讲的，不过要记住你得定义一个空的命令用来执行你定义的task命令就好</p><p>异步的三种解决方法，暂时还没有遇到异步的，等遇到了在进行补充！</p><p><strong>四 gulp.watch(glob, [, deps], [tasks])</strong><br>watch用于监听某个路径下的文件，当发生改变后会进行触发</p><ol><li>glob用法与gulp.src相同</li><li>deps可选参数，通常不需要用到</li><li>tasks是一个数组，里面是你task定义的命令，当监听被触发后，会执行定义在这里的任务</li></ol><p>gulp.task(‘copyCss’, function () {<br>    gulp.src(‘src/<em>/</em>.css’)<br>        .pipe(gulp.dest(‘dist/css))<br>})<br>gulp.task(‘dev’, function () {<br>    gulp.watch(‘src/<em>/</em>.css’, [‘copyCss’])<br>})</p><p>在package.json中 scripts中 写入 “dev”: “gulp dev” 命令</p><pre><code>npm run dev         启动命令</code></pre><p>当修改src下的css文件后，会执行copyCss命令，你在dist文件下的css就会实时更新了</p><h3 id="gulp常用插件"><a href="#gulp常用插件" class="headerlink" title="gulp常用插件"></a>gulp常用插件</h3><p><strong>gulp-load-plugins  自动载入插件</strong></p><p>安装：<br>        cnpm install --save-dev gulp-load-plugins       </p><p>功能：<br>    该插件主要解决繁多的命名空间和代码整洁度<br>    例子：<br>    var gulp = require(‘gulp’),<br>    //一些gulp插件,abcd这些命名只是用来举个例子<br>    a = require(‘gulp-a’),<br>    b = require(‘gulp-b’),<br>    c = require(‘gulp-c’),<br>    d = require(‘gulp-d’),<br>    e = require(‘gulp-e’),<br>    f = require(‘gulp-f’),<br>    g = require(‘gulp-g’)</p><p>用法：<br>    var gulp = require(‘gulp’),<br>        plugins = require(‘gulp-load-plugins’)()    //调用下方法</p><pre><code>gulp.task(&apos;default&apos;, function () {    // 例如你有个js压缩插件    gulp.src(&apos;src/js/*.js&apos;)        // gulp-uglify      //调用时值仅需要uglify即可，如果后面还有中划线，以驼峰的方式 例:gulp-minify-css  plugins.minifyCss        .pipe(plugins.uglify())        .pipe(gulp.dest(&apos;dist/js&apos;))})</code></pre><p><strong>browserSnyc  热更新</strong></p><p>安装browserSync</p><p>使用它只需要记住 在每个执行命令中需要调用一次reload方法就好，具体先看下文档~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在被大老大一顿嘲讽后，恶补了一下gulp,看了看  真的很简单呀&lt;br&gt;    gulp拥有简洁的API，使用者能够轻易上手，Gulp是一个自动化构建工具，具有强大的插件，只要搭配合适，能够大大提高我们工作中开发的效率。gulp更加强调的是开发流程，通过taskAPI可以定义符合自己的流程。&lt;br&gt;    webpack主要是模块化的规范，更加强调模块化，把各种文件看成模块，用过loader,最终打包为css/js/html/图片等&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我要对陈晨大声的说:我~~爱~~~你！</title>
    <link href="http://yoursite.com/2018/05/19/%E6%88%91%E8%A6%81%E5%AF%B9%E9%99%88%E6%99%A8%E5%A4%A7%E5%A3%B0%E7%9A%84%E8%AF%B4-%E6%88%91-%E7%88%B1-%E4%BD%A0%EF%BC%81/"/>
    <id>http://yoursite.com/2018/05/19/我要对陈晨大声的说-我-爱-你！/</id>
    <published>2018-05-19T14:58:20.000Z</published>
    <updated>2018-05-19T16:01:54.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相信我！"><a href="#相信我！" class="headerlink" title="相信我！"></a>相信我！</h3><a id="more"></a><h3 id="第一次见面"><a href="#第一次见面" class="headerlink" title="第一次见面"></a>第一次见面</h3><p>刚搬来的时候是我们第一次见面，看到你的第一眼心想：能跟这么漂亮的女孩子合租真好。</p><h3 id="第一次说话"><a href="#第一次说话" class="headerlink" title="第一次说话"></a>第一次说话</h3><p>嗯，大半夜收拾屋~，心想，这谁呀，但半夜走来走去的，还收拾屋，结果出门看到了你，就说了句大半夜还收拾屋呀，然后你害羞的说 嗯，收拾收拾，当时心想 好勤快呀！</p><h3 id="第一次一起上班"><a href="#第一次一起上班" class="headerlink" title="第一次一起上班"></a>第一次一起上班</h3><p>刚准备走呢，就看到你一个人出门，就赶紧收拾收拾，然后跟你一块出门，也是从那开始，我的生活中有了你<br><img src="/static/0519.jpg" alt="img"></p><p>然后我就知道你的出门时间，每次都会早起，然后收拾好等你，还必须要装作碰巧的样子，有一次你出门比较早，没等到，然后我第二天就又早起，必须得和你一块走！</p><h3 id="你傻傻的样子最可爱"><a href="#你傻傻的样子最可爱" class="headerlink" title="你傻傻的样子最可爱"></a>你傻傻的样子最可爱</h3><p>还记得有一次你收拾屋，美君还没回来，然后你收拾的可干净了，跟美君发微信视频，说看，这是的收拾的屋，可干净了，就等你回来了，当时我感觉你可开心可有信心了，我都想去看一看…</p><h3 id="你是我的"><a href="#你是我的" class="headerlink" title="你是我的"></a>你是我的</h3><p>然后，我就越来越喜欢你，喜欢你傻傻的很纯洁的笑，喜欢你的勤奋，喜欢你说话逗别人开心，总之，跟你接触的这段时间，你都深深的把我吸引到了，必须得追你~！</p><p>但是那天，像往常一样等你一块上班，有个男的从你卧室出来，然后你跟在他后面，当时我就心凉了一半，心想应该不是我想的那样吧，想了想，刚好你回来拿伞，在电梯门口碰见了，就问你那男的，你说是你男朋友，然后我就心全凉了，特别不开心，不过我在你们后面看到，好像不是很亲密的样子，应该没处多久，但是我是一个有原则的人，绝对不会去挖墙脚干这种事情，总之想了想，算了吧。</p><p>然后你在朋友圈发了一条说说，说你也该找一个了，当时我就感觉要上天了，必须得抓住这个机会</p><p><img src="/static/05192.jpg" alt="img"></p><p>刚好到了五一，就想着必须得下手了，然后就约你出来玩，你也很配合的来了，当时我就知道我要献出第一次了。。。哈哈哈，第一次表白，本来一直想说，但是一直缺少勇气，怕你会拒绝，但是~上了大摆锤后，是大摆锤给我的勇气，在坐下的那一瞬间我就知道我必须说了，做我的女朋友吧，说完我感觉好舒服，终于做了一件让自己感觉满意的事情，然后看你害羞的…..Emmmmmm，那一天真的好开心</p><p><img src="/static/timg.gif" alt="img"></p><p>从五一过后，我就一直在关注你，可能我也比较心急，你也说心急吃不了热豆腐，那不是怕真的错过了呗，我可是一个追求完美的人，不会轻易说认输，所以，你必须得是我的</p><h3 id="感动"><a href="#感动" class="headerlink" title="感动"></a>感动</h3><p>让我最感动的是  我说我失眠，然后你就说陪我跑步，一直坚持到现在，然后真的很有效果，有你真好！</p><h3 id="05月10日-我要你！"><a href="#05月10日-我要你！" class="headerlink" title="05月10日 我要你！"></a>05月10日 我要你！</h3><p>这一天，是我们第一次牵手，原谅我你当时问我 我没有说出来，因为当时真的懵了…</p><p><img src="/static/05193.jpg" alt="img"></p><p>你的生日是04-17 我会记住的，可能我有时候大脑会短路，多多包涵~~哈哈</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>我有时候说你胖了什么的 你别在意，我下次也不会说啦，怪我，不过我会尽量缩短我在单位的工作时间早点回来陪你跑步，直到让你对自己身材满意为止，我会陪着你的！！！</p><p>陈晨，我不是一个爱说以后的人，因为说以后真的是一个笑话，我只能说，当下我会好好的爱你，对你加倍的好，也会包容你的小脾气，每周都会给你做好吃的，带你去你想去的地方，我会好好努力，挣钱养你和我妈~相信我，当然我可能也会有点小脾气，也有很多的缺点，但是你一定要及时的提出来啦，你提的我都为了咱们去改！相信我！</p><p>最后，今天是个特殊的日子，我要大声的说</p><h1 id="陈晨，我爱-你！！！！让我们一直这样的幸福下去！"><a href="#陈晨，我爱-你！！！！让我们一直这样的幸福下去！" class="headerlink" title="陈晨，我爱~你！！！！让我们一直这样的幸福下去！"></a>陈晨，我<del>爱</del>~你！！！！让我们一直这样的幸福下去！</h1><p><img src="/static/langman.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相信我！&quot;&gt;&lt;a href=&quot;#相信我！&quot; class=&quot;headerlink&quot; title=&quot;相信我！&quot;&gt;&lt;/a&gt;相信我！&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node环境变量配置</title>
    <link href="http://yoursite.com/2018/05/16/node%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/16/node环境变量配置/</id>
    <published>2018-05-16T13:40:23.000Z</published>
    <updated>2018-05-17T01:50:00.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个环境变量实在是有点坑，前面倒腾了几次，还是有问题，现在这个问题终于解决了，我来阐述下我的配置及踩过的坑</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><pre><code>vue -V 不是内部命令node -v 不是内部命令npm -v 不是内部命令等</code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>出现以上场景都是因为你的npm路径有问题，所以导致不是命令，接下来将会配置npm</p><pre><code>1. 指定npm全局路径 </code></pre><p>我会在E盘创建nodejs文件目录，在下面分别创建node_global和node_cache文件夹</p><pre><code>2. 命令npm config set prefix &quot;d:\nodejs\node_global&quot;npm config set prefix &quot;d:\nodejs\node_cache&quot;</code></pre><p>以上命令指定npm的路径为刚刚创建的文件路径<br>    3.配置环境变量<br>环境变量分为系统变量和用户变量<br>    系统变量中新建变量名：NODE_PATH，变量值：D:\nodejs\node_global\node_modules<br>    路径还是刚刚创建时的路径<br>    用户变量中的PATH中添加：D:\nodejs\node_global</p><p>一定记得 不要在系统变量中的PATH去写，我之前就是踩的这个深坑，怎么找都找不出来，加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个环境变量实在是有点坑，前面倒腾了几次，还是有问题，现在这个问题终于解决了，我来阐述下我的配置及踩过的坑&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手机select展示样式不同</title>
    <link href="http://yoursite.com/2018/05/16/%E6%89%8B%E6%9C%BAselect%E5%B1%95%E7%A4%BA%E6%A0%B7%E5%BC%8F%E4%B8%8D%E5%90%8C/"/>
    <id>http://yoursite.com/2018/05/16/手机select展示样式不同/</id>
    <published>2018-05-16T13:32:37.000Z</published>
    <updated>2018-05-21T11:18:54.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><p>虽然今天心情不好，但是也算是学到了点东西</p><p>select在手机当中展示的样式不同，所以，为了还原UI，需要按照UI样式写</p><pre><code>将select下拉框使用定位盖在UI上面，透明度给0就可以实现，通过change事件的改变在来改变UI的DOM，此方法为最合适的方法</code></pre><p>一定要注意变通，而且不管干什么一定要注意过脑子</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下拉框&quot;&gt;&lt;a href=&quot;#下拉框&quot; class=&quot;headerlink&quot; title=&quot;下拉框&quot;&gt;&lt;/a&gt;下拉框&lt;/h3&gt;&lt;p&gt;虽然今天心情不好，但是也算是学到了点东西&lt;/p&gt;
&lt;p&gt;select在手机当中展示的样式不同，所以，为了还原UI，需要按照UI样式写
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>换电脑后如何继续写博客</title>
    <link href="http://yoursite.com/2018/04/27/%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/04/27/换电脑后如何继续写博客/</id>
    <published>2018-04-27T13:26:48.000Z</published>
    <updated>2018-05-16T13:25:59.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为有写博客的习惯，但是公司的事儿太忙了，耽搁了好久，每次回家都挺累，所以决定还是每天在公司写一篇博客吧，其实倒是有点像是日记了，不过对于每天的总结还是很有帮助的，blog文章命名一定要以功能来进行命名，这样在以后如果有类似的话很好找</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>传送门</strong> <a href="https://blog.csdn.net/eternity1118_/article/details/71194395?ref=myread" target="_blank" rel="noopener">换电脑后如何继续写博客</a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>1.找到你原来写blog的文件夹，找到<strong>_config.yml</strong>、<strong>themes</strong>、<strong>source</strong>、<strong>scaffolds</strong>、<strong>package.json</strong></p><p>2.copy到你本地  例： /hexo文件中</p><h5 id="下载hexo"><a href="#下载hexo" class="headerlink" title="下载hexo"></a>下载hexo</h5><pre><code>npm install hexo -g   </code></pre><h5 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h5><pre><code>npm install  npm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save</code></pre><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><pre><code>hexo ghexo deploy</code></pre><h3 id="加油，你不是最弱的"><a href="#加油，你不是最弱的" class="headerlink" title="加油，你不是最弱的"></a>加油，你不是最弱的</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为有写博客的习惯，但是公司的事儿太忙了，耽搁了好久，每次回家都挺累，所以决定还是每天在公司写一篇博客吧，其实倒是有点像是日记了，不过对于每
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-04-27 小组会</title>
    <link href="http://yoursite.com/2018/04/27/2018-04-27-%E5%B0%8F%E7%BB%84%E4%BC%9A/"/>
    <id>http://yoursite.com/2018/04/27/2018-04-27-小组会/</id>
    <published>2018-04-27T12:58:01.000Z</published>
    <updated>2018-04-27T13:32:46.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>来了快两个月了，因为平时比较忙，大家都比较忙，距离上次开会大概是三周前了</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>不足之处</p><pre><code>1. 针对于现在h5移动端调试问题只能使用手机终端进行调试，影响效率</code></pre><p>答： 因为需要与客户端交互，需要客户端的数据，暂时只能使用抓包工具在store当中把数据先写死进行调试</p><pre><code>2. 命名规范问题</code></pre><p>答： css遵从BEM规范进行命名</p><pre><code>3. git规范开发流程</code></pre><p>答： 首先，环境有dev(本地测试)、alpha(测试人员测试)、rc(预上线测试人员测试)、pro(正式环境)<br>git开发分支：本地创建feature/projuct  ==&gt;  提测合并alpha分支（发送邮件）  ==&gt;  测试通过合并develop分支 ==&gt;  develop分支合并至rc分支并且删除本地分支，如果有bug从rc拉取bugfix/bug分支（develop分支为一个中转站 发送邮件）  ==&gt;  测试通过合并至pro分支（在测试的邮件中回复全部发送运维）<br>需要注意的是邮件的<strong>准确性</strong></p><pre><code>4. .vue单文件组件命名方式</code></pre><p>答： 该文件命名规范为大驼峰例：List.vue BaseInfo.vue</p><p>老大说的几句话挺对的</p><pre><code>1. 设计简单合理2. UI设计，审美观念3. 提高自我价值，变强4. 愿意接受改变，接受别人的建议5. 当封装公共组件时，最好大家一起讨论下设计思想，能够减少返工时间，提高开发效率</code></pre><p>在设计的时候最好有至少两种的设计理念，并且当拿到需求时，一定要先自己设计一遍，不要埋头就干，不过我对着这个还是有满满的自信的，对于审美方面，也许是我自己太死板了，没有用心，没有把自己当成一个客户，可能比较随意，这点我会改正，加油吧！！！</p><h3 id="不管如何，你都要去克服，去接受，把它变为自己的"><a href="#不管如何，你都要去克服，去接受，把它变为自己的" class="headerlink" title="不管如何，你都要去克服，去接受，把它变为自己的"></a>不管如何，你都要去克服，去接受，把它变为自己的</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;来了快两个月了，因为平时比较忙，大家都比较忙，距离上次开会大概是三周前了&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间戳转换年月日小月问题</title>
    <link href="http://yoursite.com/2018/04/22/%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%B9%B4%E6%9C%88%E6%97%A5%E5%B0%8F%E6%9C%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/22/时间戳转换年月日小月问题/</id>
    <published>2018-04-22T11:55:43.000Z</published>
    <updated>2018-04-22T12:21:21.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从今天开始，更新文章只针对于功能块进行更新，可能一次几个标题，这样能够在后面的日子中可以找到相关问题，规范一下</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>针对于时间转换的问题在工作当中可是用的很多的，比如这次的时间需求，1.##格式正确##，2.##结束时间不能大于开始时间##，3.##有效时间##</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>new Date(‘2017/02/02 00:00:00’)</p><p>对于这种时间 我是将格式放入new Date当中进行装换，这样的话问题1，2都可解决，对于问题三就是今天得重点</p><p>大家都知道有大小月，问题在于用这个转换小月的话还是会合法，比如2018/02/31</p><p><img src="/static/04-22-1.png" alt="img"></p><p>大家看到问题了吧，对！就是在小月31日时也是合法，但是会转换为别的日期</p><p>解决，在转换前和转换后进行对比就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;从今天开始，更新文章只针对于功能块进行更新，可能一次几个标题，这样能够在后面的日子中可以找到相关问题，规范一下&lt;/p&gt;
&lt;h3 id=&quot;需求
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阿西吧</title>
    <link href="http://yoursite.com/2018/04/15/%E9%98%BF%E8%A5%BF%E5%90%A7/"/>
    <id>http://yoursite.com/2018/04/15/阿西吧/</id>
    <published>2018-04-15T12:06:56.000Z</published>
    <updated>2018-04-15T12:35:58.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知不觉的，已经一个月没有更新了，最近工作真的很忙，简直没有时间，不过，在这段时间内，老大对于我的纠正，我也学会了很多的东西，比如element UI算是熟悉了，对于Jquery的操作也基本都会了（以前真的没怎么用过），主要来说，我的问题还是在命名规范的上面，简直被老大喷的不要不要的，不过老大对我很好，每次都是好好的说，对于前端UI上面的设计也算是有点体会了。</p><h3 id="Element-form自带验证"><a href="#Element-form自带验证" class="headerlink" title="Element form自带验证"></a>Element form自带验证</h3><p>刚开始解除，对于这种验证格式真的没有解除过，导致返工了很多的东西，Element 对于 form表单验证做的还是比较的齐全的</p><p><img src="/static/04-15-1.png" alt="img"></p><p>引入各种就不多说了现在只说下用法</p><p><el-form :rules="rules" ref="form" :model="ruleForm"></el-form></p><p>:model 表单数据对象<br>:rules 表单验证规则<br>ref 需要调用Element 封装的内部方法</p><p>以上三者为必须！</p><p>model 就是你data里面需要初始化的值</p><p>eg:ruleForm: {<br>          name: ‘’,<br>        }</p><p>在v-model当中写入对应的即可<br>rules 验证方式分为两种，一种为行内，一种写在data当中</p><p><strong>行内</strong><br>    <el-form-item prop="name" rules="[        { required: true, message: '请输入姓名', trigger: 'blur' },    ]"></el-form-item><br>其中，required为必填项,也就是左边那个##*##样式</p><p><strong>data中定义</strong></p><pre><code>data () {    return {        rules:{            name: { type: &apos;String&apos;, required: true, message: &apos;请选择名称&apos;, trigger: &apos;blur&apos; }        }    }}</code></pre><p>以上为rules的定义规则</p><p>这里还要说一下自定义验证<br>    data () {<br>        var nameVerification = function (rule, value, callback) {<br>            // 业务逻辑</p><pre><code>        value 失去焦点的值        callback 一定要记住，不管你的验证是否通过都必须有callback调用，否则在点击确定按钮将会无效！！！！    }     return {        rules:{             name: { validator: nameVerification, trigger: &apos;blur&apos; }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;不知不觉的，已经一个月没有更新了，最近工作真的很忙，简直没有时间，不过，在这段时间内，老大对于我的纠正，我也学会了很多的东西，比如eleme
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git日常基本指令</title>
    <link href="http://yoursite.com/2018/03/14/git%E6%97%A5%E5%B8%B8%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/14/git日常基本指令/</id>
    <published>2018-03-14T05:33:33.000Z</published>
    <updated>2018-03-14T05:50:09.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好久没有更新了，这段时间也忙也闲，金三银四，大家都在各自的公司因为各种原因都在进行着面试，我也一样，上周收到了offer，这周就赶紧进行交接，心情也还不错，可惜就是我的团队我很不舍得离开，大家都对我很好，哎，好不舍，但是现实就是这样，没有不散的宴席，大家加油吧，我相信你们会更好的！</p><p><img src="http://img1.imgtn.bdimg.com/it/u=2417507986,147620643&amp;fm=27&amp;gp=0.jpg" alt="img"></p><a id="more"></a><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>对于现在的协同开发者工具<strong>Git</strong>、<strong>SVN</strong>大家应该都已经很熟悉了，当然，现在还是Git使用的更多一些，并且也有很多的优势，安装什么的就不说，只是简单的复习一下简单的命令，不喜勿喷</p><pre><code>git add .               提交全部文件git commit -m &quot;注释&quot;    提交到本地git pull                拉取代码，解决冲突git add .git commit -m &quot;注释&quot;git push                进行远程推送的仓库当中git push origin 分支名  也可完成推送</code></pre><p>这是简单的提交</p><p>创建分支</p><pre><code>git checkout -b &quot;分知名&quot;git push origin &quot;创建的分知名&quot;    推送到远端</code></pre><p>查看分支</p><pre><code>git branch</code></pre><p>合并分支</p><pre><code>git merge 分支名</code></pre><p>注：合并分支后先进行解决冲突</p><p>查看日志</p><pre><code>git log         查看全部日志git log -p      查看已提交详情的修改git log -p -2   查看最近两次的详情修改</code></pre><p>回退版本</p><pre><code>git reset --hard 版本号</code></pre><p>注：在这里回退的版本后，使用git log 只能打印到你回退版本的时间记录处，所以，大家一定要做好备份！！！！！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;好久没有更新了，这段时间也忙也闲，金三银四，大家都在各自的公司因为各种原因都在进行着面试，我也一样，上周收到了offer，这周就赶紧进行交接，心情也还不错，可惜就是我的团队我很不舍得离开，大家都对我很好，哎，好不舍，但是现实就是这样，没有不散的宴席，大家加油吧，我相信你们会更好的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.imgtn.bdimg.com/it/u=2417507986,147620643&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈原型链 prototype __proto__</title>
    <link href="http://yoursite.com/2018/03/03/%E6%B5%85%E8%B0%88%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype-proto/"/>
    <id>http://yoursite.com/2018/03/03/浅谈原型链-prototype-proto/</id>
    <published>2018-03-03T03:16:01.000Z</published>
    <updated>2018-03-03T04:06:59.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>hi，这两天都比较忙，好不容易有点时间立刻就来更新啦~，因为项目都是由Vue进行开发的，一直想看看源码，但是又限于自己的原因，所以先来对面向对象来总结总结！~</p><p><img src="http://img5.imgtn.bdimg.com/it/u=2822639283,850849670&amp;fm=11&amp;gp=0.jpg" alt="img"></p><a id="more"></a><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>相信大家对于对象来说都很熟悉了，在js当中万物皆对象嘛！</p><p>对于prototype大家都知道，每一个函数都会有一个prototype属性，但是<strong>proto</strong>是个什么呢？</p><p>请看下面一段代码</p><pre><code>let obj = {};obj.prototype.a = function(){       //解析到这会报错,实例中是无法使用prototype}obj.a();</code></pre><p><img src="/static/o1.png" alt="img"></p><p>为什么呢？ 因为prototype是只有函数拥有的属性，在对象实例中是无法使用的，那如何实现呢？</p><pre><code>function Man(height){    this.height = height}let obj = new Man(178);Man.prototype.a = function(){    alert(this.height)}obj.a();</code></pre><p>代码运行正常</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>每一个对象都拥有<strong>proto</strong>属性，这个属性是用来指向构造函数的prototype的<br>每一个函数都拥有prototype属性，通过<strong>proto</strong>来指向prototype来实现<strong>继承</strong><br>每一个函数都拥有constructor属性，指向所有原型实例的构造函数</p><p>找一个实例的属性 会进行递归操作：</p><p>实例属性 =&gt; __proto =&gt; 实例属性构造函数的prototype =&gt; obj.prototype 为止</p><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><p><img src="https://segmentfault.com/img/bVT7ae?w=423&amp;h=513" alt="img"></p><p>暂时更新这么多啦，一起加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;hi，这两天都比较忙，好不容易有点时间立刻就来更新啦~，因为项目都是由Vue进行开发的，一直想看看源码，但是又限于自己的原因，所以先来对面向对象来总结总结！~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img5.imgtn.bdimg.com/it/u=2822639283,850849670&amp;amp;fm=11&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
