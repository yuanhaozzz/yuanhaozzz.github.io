<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-04T09:16:37.962Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>渡丶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6-函数扩展</title>
    <link href="http://yoursite.com/2018/07/04/ES6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/04/ES6-函数扩展/</id>
    <published>2018-07-04T08:29:23.000Z</published>
    <updated>2018-07-04T09:16:37.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加油！<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><pre><code>function fn (x = 2) {    console.log(x)}fn(10)  // 10fn()    // 2</code></pre><p>无法使用Let 和 const再次进行声明，他们是唯一的</p><pre><code>function fn (x = 2) {    let x = 1    console.log(x)}fn(10)// 报错</code></pre><p>同样可是使用解构的方式</p><pre><code>function foo({x, y}) {    console.log(x, y());}foo({x: 1, y: () =&gt; 8})// x 1// y 8</code></pre><p>也可以指定默认值</p><pre><code>function foo({x = 50, y}) {    console.log(x, y());}foo({y: () =&gt; 8})// x 50// y 8</code></pre><h3 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h3><p>基本用法</p><pre><code>function fn(...arr) {    let sum = 0    arr.forEach(item =&gt; {        sum += item    })    return sum}console.log(fn(1, 2, 3))    // 6</code></pre><p>转换数组的方式</p><pre><code>// 方法1 function fn() {    return Array.prototype.slice.call(arguments)}// 方法2 rest function fn1(...arr) {    return arr}// 方法3 Array.from()function fn2() {    console.log(Array.from(arguments))}</code></pre><p>注意 rest后面不能再跟参数，否则会报错</p><pre><code>function fn(one, ...arr, num) {    // ...}fn(1,5,6,2)// 报错</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数使用为最多，他不仅语法简洁，降低代码量，同时更具有可读性</p><pre><code>let obj = {name: &apos;aa&apos;}let f = item =&gt; item.nameconsole.log(f(obj))     // aa</code></pre><p>如果没有参数 或者 有多个参数 用圆括号</p><pre><code>let a = () =&gt; 5let b = (num1, num2) =&gt; num1 + num2// 等同于let a = function () {    return 5}let b = function (num1, num2) {    return num1 + num2}</code></pre><p>只有代码为1行时不用写return </p><pre><code>let a = (item) =&gt; {    if (item.id === 1) {        return item    }}</code></pre><p>配合解构</p><pre><code>let obj = {    a: function () {        alert(88)    },    b: 10,    c: 16}let fn = ({a, b}) =&gt; a()    fn(obj) // 88let fn = ({c, b = 7}) =&gt; b + c  fn(obj) // 26</code></pre><p>默认值</p><pre><code>let obj = {    a: function () {        alert(88)    },    c: 16}let fn = ({c, b = 7}) =&gt; b + c  fn(obj)     // 23</code></pre><p>来看这个例子</p><pre><code>function Timer() {    this.s1 = 0;    this.s2 = 0;    // 箭头函数    setInterval(() =&gt; this.s1++, 1000);    // 普通函数    setInterval(function () {        this.s2++;        // alert(this.s2)    }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);   // 3setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);   // 0// 使用箭头函数 this会指向定义时的对象，所以s1会在3秒调用3次 为3  s2 的this指向了window的s2 并不存在 3秒内都是window的s2 在++ ，相加为NAN  但是是打印的当前构造函数内的s2，所以值为0</code></pre><p>所以下面为被编译的ES5</p><pre><code>let a = () =&gt; {    setTimeout(() =&gt; {        console.log(this.id)    }, 2000);}let a = function () {    var _this = this    setTimeout(() =&gt; {        console.log(_this.id)    }, 2000);}</code></pre><h3 id="箭头函数总结"><a href="#箭头函数总结" class="headerlink" title="箭头函数总结"></a>箭头函数总结</h3><pre><code>1. 代码简洁，更具有可读性2. this指向定义时的对象，并不是调用时的3. 因为本身并没有this,无法作为构造函数，无法使用New4. 没有arguments对象，不过可以使用rest   ...arr</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加油！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-字符串扩展</title>
    <link href="http://yoursite.com/2018/07/04/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/04/ES6-字符串扩展/</id>
    <published>2018-07-04T06:23:21.000Z</published>
    <updated>2018-07-04T08:47:17.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加油！<br><a id="more"></a></p><p>遵循二八，只写常用的</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>在ES5中 查找字符串是否存在使用indexOf 大于-1则存在，ES6出了个方法，includes,改方法返回boolean</p><pre><code>let str = &apos;卫栖梧dqweqwe4152&apos;console.log(str.includes(&apos;5&apos;))      // trueconsole.log(str.includes(&apos;10&apos;))      // falseconsole.log(str.includes(&apos;dqwe&apos;))      // true</code></pre><p>startsWith 第一个是否为某一项<br>endsWith 最后一个是否为某一项</p><pre><code>let str = &apos;卫栖梧dqweqwe4152&apos;console.log(str.startsWith(&apos;5&apos;))    // falseconsole.log(str.endsWith(&apos;2&apos;))      // true</code></pre><p>repeat 重复字符串</p><pre><code>// console.log(&apos;aaa&apos;.repeat(8))         // aaaaaaaaaaaaaaaaaaaaaaaa</code></pre><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>先看常规拼接字符串</p><pre><code>let a = &apos;谁最帅&apos;let b = &apos;当然是我&apos;console.log(&apos;现在&apos; + a + &apos;,&apos; + b + &apos;啦&apos;)    //现在谁最帅,当然是我啦</code></pre><p>ES6 字符串模板<br>    console.log(<code>现在${a},${b}啦</code>)      //现在谁最帅,当然是我啦</p><p>这样的写法更具有可读性，更加简洁，同时字符串模板支持简单的运算，可写函数返回，还支持隔行</p><pre><code>let a = &apos;拼接&apos;let b = &apos;字符串&apos;function name () {    return &apos;我是函数&apos;}let c = `我在${a}${b}    ${name()}`console.log(c)// 我在拼接字符串        我是函数</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加油！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-解构赋值</title>
    <link href="http://yoursite.com/2018/06/27/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2018/06/27/ES6-解构赋值/</id>
    <published>2018-06-27T11:49:59.000Z</published>
    <updated>2018-07-04T08:09:01.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>只想每天学习新的总结那么一点，不想原地踏步<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>解构分为数组解构、对象解构、字符串解构、函数参数解构,还有些不常用的，就不说了</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>通常我们进行赋值</p><pre><code>let a = &apos;a&apos;let b = &apos;b&apos;let c = &apos;c&apos;</code></pre><p>ES6提供数组解构为</p><pre><code>let [a, b, c] = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]a // &apos;a&apos;b // &apos;b&apos;c // &apos;c&apos;</code></pre><p>从上述可以看得出来，数组组件主要针对位置来进行赋值</p><p>也可写成这样<br>    let [a, [b, c]] = [10, [20, 30]]<br>    a // 10<br>    b // 20<br>    c // 30</p><p>如果对应位置没有对应值，则为undefined<br>    let [a, [b, c]] = [10, [, 30]]<br>    a // 10<br>    b // undefined<br>    c // 30</p><p>也可初始化值</p><pre><code>let [a=5, [b=3, c]] = [10, [, 30]]a // 10b // 3c // 30</code></pre><p>// 需要注意！只有当等于undefined时才会被赋值默认值，注意是全等，严格模式</p><pre><code>let [a=5, [b=3, c]] = [10, [null, 30]]a // 10b // nullc // 30</code></pre><p>赋值必须是可迭代的(iterator)</p><pre><code>let [a=5,b] = 1// 报错</code></pre><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>这样写会抛出错误<br>    let {a:10,b:10} = {a:20,b: 40}</p><p>原因，对象解构与数组解构不同，数组解构是通过对应位置，而对象解构则通过 等号 左边的键 去查找 右侧的键值，在找到后，赋值给右侧的值</p><pre><code>let {a: b,c: d} = {a: 50, c: 90}a //undefinedb // 50c // undefinedd // 90</code></pre><p>看到这应该明白了  也就是收  通过a 到 右边去找到对应的值，然后从新赋值给b  这就是区别</p><p>设定默认值</p><pre><code>let {a: b=10,c: d=4} = {a: undefined, c: undefined}b // 10d // 4</code></pre><h3 id="函数参数解构"><a href="#函数参数解构" class="headerlink" title="函数参数解构"></a>函数参数解构</h3><pre><code>function a () {    alert(&apos;a&apos;)}function b () {    alert(&apos;b&apos;)}function move ([a, b]) {    a()}move([a, b])</code></pre><p>总之,把数组解构 和 对象解构 理解了 其他都差不多</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;只想每天学习新的总结那么一点，不想原地踏步&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue，公共tab跳转不同路由页面样式切换</title>
    <link href="http://yoursite.com/2018/06/08/Vue%EF%BC%8C%E5%85%AC%E5%85%B1tab%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E8%B7%AF%E7%94%B1%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/06/08/Vue，公共tab跳转不同路由页面样式切换/</id>
    <published>2018-06-08T08:53:27.000Z</published>
    <updated>2018-06-08T11:35:27.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>先有一个公共tab组件用来分别跳转不同路由的页面</p><p>例<br>    a 公共组件<br>    b 点击跳转页面<br>    c 点击跳转页面</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>两种方法解决选中样式问题</p><ol><li>router-link标签 （推荐）<br><router-link to="/a" active-class="active"><br><router-link to="/b" active-class="active"></router-link></router-link></li></ol><p>active为选中的样式</p><ol start="2"><li>通过路由当前参数来进行判断</li></ol><p>data () {<br>    return {<br>        active: this.$route.query.index || 0<br>    }<br>}</p><p>在跳转时传递不同参数  选项卡通过当前active来进行判断，实现样式的切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;p&gt;先有一个公共tab组件用来分别跳转不同路由的页面&lt;/p&gt;
&lt;p&gt;例&lt;br&gt;    a 公共组件&lt;br&gt;    b 点击跳转页面&lt;br&gt;   
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>v-html</title>
    <link href="http://yoursite.com/2018/06/07/v-html/"/>
    <id>http://yoursite.com/2018/06/07/v-html/</id>
    <published>2018-06-07T07:50:58.000Z</published>
    <updated>2018-06-08T08:51:31.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>v-html 渲染出来的标签无法修改样式</p><p>结构</p><pre><code>&lt;div class=&quot;wrap&quot;&gt;    &lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>解决</p><pre><code>.wrap &gt;&gt;&gt;div{    //.....}.wrap &gt;&gt;&gt;span{    //.....}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小技巧&quot;&gt;&lt;a href=&quot;#小技巧&quot; class=&quot;headerlink&quot; title=&quot;小技巧&quot;&gt;&lt;/a&gt;小技巧&lt;/h3&gt;&lt;p&gt;v-html 渲染出来的标签无法修改样式&lt;/p&gt;
&lt;p&gt;结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="http://yoursite.com/2018/05/25/vuex/"/>
    <id>http://yoursite.com/2018/05/25/vuex/</id>
    <published>2018-05-25T11:45:26.000Z</published>
    <updated>2018-06-07T07:49:54.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vuex,个人理解为一个提供全局公用的属性及方法，是中大型开发项目架构中不可缺少的一部分，他的设计及使用都很方便，便于协同开发。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install --save-dev vuex</code></pre><p>安装至package.json中开发依赖</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>main.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import store from &apos;./store/index&apos;Vue.use(Vuex)               // 全局配置new Vue({    el: &apos;#app&apos;,    router,    store,                  // 导入全局    render: h =&gt; h(App)})</code></pre><p>store/index.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)               // 全局配置let store = {    state: {        ....    },    getters: {        ....    },    mutations: {        ....    },    actions: {        ....    }}//导出storeexport default store</code></pre><p>以上是store的基本配置</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>存储数据的，任何属性的定义都在里</p><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以理解为Vue的计算属性，假设有这样一个需求  需要让你过滤出小于25的数</p><pre><code>let sotre = {    state: {        data: [10, 50, 10, 40]    }}当然聪明你的肯定在组件中轻易的就可以写出来，但是如果换一个页面的话 是不是还要在写一遍？如果10， 20个的话 是不是就吐啦？？，所以getters就来解决这种问题</code></pre><p>store/index.js</p><pre><code>let sotre = {    state: {        data: [10, 50, 10, 40]    },    getters: {        filterData (state) {            return state.data.filter(item =&gt; item &lt; 25)        }    }}</code></pre><p>index.vue</p><pre><code>mounted () {    // 获取已过滤出的数据    let data = this.$store.getters.filterData}</code></pre><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>想要修改state 中的数据 ，只能mutations来进行修改，并且它是同步的，稍后会讲到action（异步），这种模式能够更加清晰的知道你的数据是什么来进行改变的，具有可读性和可维护性</p><p>store/index.js</p><pre><code>state: {    name: &apos;张三&apos;},getters: {    filterData (state) {        return state.data.filter(item =&gt; item &lt; 25)    }},mutations: {    changeName1 (state) {        state.name = &apos;李四&apos;    },    changeName2 (state, people) {        state.name = people.name    }}</code></pre><p>index.vue</p><pre><code>// 调用1html{{ this.$store.state.name }}  // 李四mounted () {    this.$store.commit(&apos;changeData&apos;)}// 调用2html{{ this.$store.state.name }}  // aamounted () {    // 传值方式1    this.$store.commit(&apos;changeData&apos;, {        name: &apos;aa&apos;    })    // 传值方式2    this.$store.commit({        type: &apos;changeData&apos;,        name: &apos;aa&apos;    })}</code></pre><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>前面说到了 mutations 是使用同步来进行解决的，异步的话使用action来处理，为什么呢？ 首先，得按照人家的规矩的来不是？ 其次，还是因为追踪数据，如果mutations使用了异步，无法追踪到数据改变的纪录，同时有时会导致错误，无法进行赋值，前面说了只能通过mutations来进行改变，所以action所做的就是调用mutations内的函数，通过实参传递过去。</p><p>store/index.js</p><pre><code>state: {    arr: &apos;张三&apos;,    userInfo: []},getters: {    filterData (state) {        return state.data.filter(item =&gt; item &lt; 25)    },    userInfo: state =&gt; state.userInfo},mutations: {    changeArr (state) {        state.arr = data      },    changeArr1 (state, data) {        state.arr = data.data    }},action: {    asynChangeName ({commit}) {         // es6函数参数解构        commit(&apos;changeName&apos;)            // 基本调用    },    asynChangeName1 ({commit}) {         // es6函数参数解构        let data = [            {                name: &apos;加油&apos;,                age: 10            }, {                name: &apos;你是&apos;,                age: 15            }, {                name: &apos;最棒的&apos;,                age: 20            },        ]        setTimeOut(() =&gt; {            commit(&apos;changeName&apos;, data)      // 异步通过这种方式来进行赋值        }, 200)    },    asynChangeName2 ({commit}) {        new Promise((resolve, rejuct) =&gt; {            let random = Math.random()            if (random &gt; 0.5) {                resolve(random)            } else {                rejuct(&apos;小于0.5哦&apos;)            }        })    },    getUserInfo () {    }}</code></pre><p>index.vue</p><pre><code>mounted () {    let num = this.$store.dispatch(&apos;asynChangeName2&apos;)    num.then((resolve) =&gt; {        alert(resolve)    })}</code></pre><p>main.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import Router from &quot;vue-router&quot;import store from &apos;./store/index&apos;Vue.use(Vuex)               // 全局配置Vue.use(Router)             // 全局路由Router.beforeEach((to, from, next) =&gt; {    if (store.state.userInfo.length === 0) {        next({            path: &apos;/&apos;        })    }    next()})new Vue({    el: &apos;#app&apos;,    router,    store,                  // 导入全局    render: h =&gt; h(App)})一个简单的路由守卫拦截的登录功能，同样具有拦截效果的是axios，具体在后面我会更新</code></pre><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>当你的项目越来越庞大，store会变的臃肿，所以你需要继续把它拆分出来，更具有可维护性</p><p>store/index.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import User from &apos;./store/common/user.js&apos;import Other from &apos;./store/common/other.js&apos;Vue.use(Vuex)export default new Vuex.Store({    modules: {        User,        Other    }})</code></pre><p>store/common/user.js</p><pre><code>let User = {    state: {        ...    },    mutations: {    }}export default User</code></pre><p>store/common/other.js</p><pre><code>let Other = {    state: {        ...    },    mutations: {    }}export default Other</code></pre><p>以上是个人理解Vuex，让我们继续努力加油吧！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vuex,个人理解为一个提供全局公用的属性及方法，是中大型开发项目架构中不可缺少的一部分，他的设计及使用都很方便，便于协同开发。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gulp</title>
    <link href="http://yoursite.com/2018/05/21/gulp/"/>
    <id>http://yoursite.com/2018/05/21/gulp/</id>
    <published>2018-05-21T11:19:16.000Z</published>
    <updated>2018-05-25T11:44:42.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在被大老大一顿嘲讽后，恶补了一下gulp,看了看  真的很简单呀<br>    gulp拥有简洁的API，使用者能够轻易上手，Gulp是一个自动化构建工具，具有强大的插件，只要搭配合适，能够大大提高我们工作中开发的效率。gulp更加强调的是开发流程，通过taskAPI可以定义符合自己的流程。<br>    webpack主要是模块化的规范，更加强调模块化，把各种文件看成模块，用过loader,最终打包为css/js/html/图片等</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">前端构建工具gulpjs的使用介绍及技巧 - 无双 - 博客园</a></p><h3 id="gulp-工作模式"><a href="#gulp-工作模式" class="headerlink" title="gulp 工作模式"></a>gulp 工作模式</h3><p>gulp是基于nodejs的stream流的概念，通过pipe()来导入到你想要让他去的地方，是一个抽象的概念，比如gulp.src获取到相关内容，通过.pipe导入到插件中，在通过插件处理后，在通过pipe导入，通过gulp.dest来指定到相应位置</p><h3 id="四大API"><a href="#四大API" class="headerlink" title="四大API"></a>四大API</h3><p><strong>一 gulp.src(glob, [, option])</strong><br>    该方法主要获取到你的文件源，通过这个路径来找到对应的文件</p><ol><li>glob类似于正则表达式，主要通过这个来找到文件</li><li>option 可选参数，通常不需要用到</li></ol><p>主要讲讲glob</p><pre><code>*                   // 匹配0个或多个字符，但不会匹配到路径分隔符**                  // 匹配所有字符，包括路径分隔符?                   // 匹配文件中的一个字符，不包含路径分隔符[...]               // 匹配方括号中的所有路径，如果出现^或者!，则匹配时不会去找相应文件</code></pre><p>例子：</p><pre><code>*                   // 能匹配a.js/b.css/d.html/aa    但不包含b/a.js*.*                 // 能匹配.后缀名所有的文件**                  // 能匹配所有文件，包含b/a.js c/d.css*/*/*.*             // 能匹配a/b/a.js / c/d/b.css[&apos;*/abc/*.js&apos;]      // 匹配c/abc/e.js / v/abc/ss.js[&apos;!c/abc/*.js&apos;, &apos;c/abc/*.css&apos;]     // 不会匹配c/abc/下的所有js</code></pre><p><strong>二 gulp.dest(path, [, option])</strong><br>该方法主要把经过<strong>插件处理</strong> 或 <strong>gulp.src命令</strong>中的stream流写入到指定的文件路径</p><ol><li>path指定路径</li><li>option 可选参数，通常不需要用到</li></ol><p>例子：<br>    gulp.task(‘default’, function () {<br>        gulp.src(‘src/css/*.css’)<br>            .pipe(gulp.dest(‘dist/css’))<br>    })</p><p>task命令稍后会讲，以上功能只是一个简单的复制功能，就是找到src/css下所有css文件，通过dest命令写入dist/css文件中</p><p><strong>三 gulp.task(name, [, deps], fn)</strong><br>task方法用于定义命令</p><ol><li>name为命令的名称</li><li>deps依赖任务的队列，如果你对执行顺序有要求，以数组的方式依次写入顺序即可</li><li>fn业务逻辑</li></ol><p>创建一个依赖队列的任务执行<br>gulp.task(‘test’, [‘a’, ‘b’, ‘c’, ‘d’], function () {<br>    // …..<br>})</p><p>这个命令也没啥好讲的，不过要记住你得定义一个空的命令用来执行你定义的task命令就好</p><p>异步的三种解决方法，暂时还没有遇到异步的，等遇到了在进行补充！</p><p><strong>四 gulp.watch(glob, [, deps], [tasks])</strong><br>watch用于监听某个路径下的文件，当发生改变后会进行触发</p><ol><li>glob用法与gulp.src相同</li><li>deps可选参数，通常不需要用到</li><li>tasks是一个数组，里面是你task定义的命令，当监听被触发后，会执行定义在这里的任务</li></ol><p>gulp.task(‘copyCss’, function () {<br>    gulp.src(‘src/<em>/</em>.css’)<br>        .pipe(gulp.dest(‘dist/css))<br>})<br>gulp.task(‘dev’, function () {<br>    gulp.watch(‘src/<em>/</em>.css’, [‘copyCss’])<br>})</p><p>在package.json中 scripts中 写入 “dev”: “gulp dev” 命令</p><pre><code>npm run dev         启动命令</code></pre><p>当修改src下的css文件后，会执行copyCss命令，你在dist文件下的css就会实时更新了</p><h3 id="gulp常用插件"><a href="#gulp常用插件" class="headerlink" title="gulp常用插件"></a>gulp常用插件</h3><p><strong>gulp-load-plugins  自动载入插件</strong></p><p>安装：<br>        cnpm install --save-dev gulp-load-plugins       </p><p>功能：<br>    该插件主要解决繁多的命名空间和代码整洁度<br>    例子：<br>    var gulp = require(‘gulp’),<br>    //一些gulp插件,abcd这些命名只是用来举个例子<br>    a = require(‘gulp-a’),<br>    b = require(‘gulp-b’),<br>    c = require(‘gulp-c’),<br>    d = require(‘gulp-d’),<br>    e = require(‘gulp-e’),<br>    f = require(‘gulp-f’),<br>    g = require(‘gulp-g’)</p><p>用法：<br>    var gulp = require(‘gulp’),<br>        plugins = require(‘gulp-load-plugins’)()    //调用下方法</p><pre><code>gulp.task(&apos;default&apos;, function () {    // 例如你有个js压缩插件    gulp.src(&apos;src/js/*.js&apos;)        // gulp-uglify      //调用时值仅需要uglify即可，如果后面还有中划线，以驼峰的方式 例:gulp-minify-css  plugins.minifyCss        .pipe(plugins.uglify())        .pipe(gulp.dest(&apos;dist/js&apos;))})</code></pre><p><strong>browserSnyc  热更新</strong></p><p>安装browserSync</p><p>使用它只需要记住 在每个执行命令中需要调用一次reload方法就好，具体先看下文档~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在被大老大一顿嘲讽后，恶补了一下gulp,看了看  真的很简单呀&lt;br&gt;    gulp拥有简洁的API，使用者能够轻易上手，Gulp是一个自动化构建工具，具有强大的插件，只要搭配合适，能够大大提高我们工作中开发的效率。gulp更加强调的是开发流程，通过taskAPI可以定义符合自己的流程。&lt;br&gt;    webpack主要是模块化的规范，更加强调模块化，把各种文件看成模块，用过loader,最终打包为css/js/html/图片等&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我要对陈晨大声的说:我~~爱~~~你！</title>
    <link href="http://yoursite.com/2018/05/19/%E6%88%91%E8%A6%81%E5%AF%B9%E9%99%88%E6%99%A8%E5%A4%A7%E5%A3%B0%E7%9A%84%E8%AF%B4-%E6%88%91-%E7%88%B1-%E4%BD%A0%EF%BC%81/"/>
    <id>http://yoursite.com/2018/05/19/我要对陈晨大声的说-我-爱-你！/</id>
    <published>2018-05-19T14:58:20.000Z</published>
    <updated>2018-05-19T16:01:54.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相信我！"><a href="#相信我！" class="headerlink" title="相信我！"></a>相信我！</h3><a id="more"></a><h3 id="第一次见面"><a href="#第一次见面" class="headerlink" title="第一次见面"></a>第一次见面</h3><p>刚搬来的时候是我们第一次见面，看到你的第一眼心想：能跟这么漂亮的女孩子合租真好。</p><h3 id="第一次说话"><a href="#第一次说话" class="headerlink" title="第一次说话"></a>第一次说话</h3><p>嗯，大半夜收拾屋~，心想，这谁呀，但半夜走来走去的，还收拾屋，结果出门看到了你，就说了句大半夜还收拾屋呀，然后你害羞的说 嗯，收拾收拾，当时心想 好勤快呀！</p><h3 id="第一次一起上班"><a href="#第一次一起上班" class="headerlink" title="第一次一起上班"></a>第一次一起上班</h3><p>刚准备走呢，就看到你一个人出门，就赶紧收拾收拾，然后跟你一块出门，也是从那开始，我的生活中有了你<br><img src="/static/0519.jpg" alt="img"></p><p>然后我就知道你的出门时间，每次都会早起，然后收拾好等你，还必须要装作碰巧的样子，有一次你出门比较早，没等到，然后我第二天就又早起，必须得和你一块走！</p><h3 id="你傻傻的样子最可爱"><a href="#你傻傻的样子最可爱" class="headerlink" title="你傻傻的样子最可爱"></a>你傻傻的样子最可爱</h3><p>还记得有一次你收拾屋，美君还没回来，然后你收拾的可干净了，跟美君发微信视频，说看，这是的收拾的屋，可干净了，就等你回来了，当时我感觉你可开心可有信心了，我都想去看一看…</p><h3 id="你是我的"><a href="#你是我的" class="headerlink" title="你是我的"></a>你是我的</h3><p>然后，我就越来越喜欢你，喜欢你傻傻的很纯洁的笑，喜欢你的勤奋，喜欢你说话逗别人开心，总之，跟你接触的这段时间，你都深深的把我吸引到了，必须得追你~！</p><p>但是那天，像往常一样等你一块上班，有个男的从你卧室出来，然后你跟在他后面，当时我就心凉了一半，心想应该不是我想的那样吧，想了想，刚好你回来拿伞，在电梯门口碰见了，就问你那男的，你说是你男朋友，然后我就心全凉了，特别不开心，不过我在你们后面看到，好像不是很亲密的样子，应该没处多久，但是我是一个有原则的人，绝对不会去挖墙脚干这种事情，总之想了想，算了吧。</p><p>然后你在朋友圈发了一条说说，说你也该找一个了，当时我就感觉要上天了，必须得抓住这个机会</p><p><img src="/static/05192.jpg" alt="img"></p><p>刚好到了五一，就想着必须得下手了，然后就约你出来玩，你也很配合的来了，当时我就知道我要献出第一次了。。。哈哈哈，第一次表白，本来一直想说，但是一直缺少勇气，怕你会拒绝，但是~上了大摆锤后，是大摆锤给我的勇气，在坐下的那一瞬间我就知道我必须说了，做我的女朋友吧，说完我感觉好舒服，终于做了一件让自己感觉满意的事情，然后看你害羞的…..Emmmmmm，那一天真的好开心</p><p><img src="/static/timg.gif" alt="img"></p><p>从五一过后，我就一直在关注你，可能我也比较心急，你也说心急吃不了热豆腐，那不是怕真的错过了呗，我可是一个追求完美的人，不会轻易说认输，所以，你必须得是我的</p><h3 id="感动"><a href="#感动" class="headerlink" title="感动"></a>感动</h3><p>让我最感动的是  我说我失眠，然后你就说陪我跑步，一直坚持到现在，然后真的很有效果，有你真好！</p><h3 id="05月10日-我要你！"><a href="#05月10日-我要你！" class="headerlink" title="05月10日 我要你！"></a>05月10日 我要你！</h3><p>这一天，是我们第一次牵手，原谅我你当时问我 我没有说出来，因为当时真的懵了…</p><p><img src="/static/05193.jpg" alt="img"></p><p>你的生日是04-17 我会记住的，可能我有时候大脑会短路，多多包涵~~哈哈</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>我有时候说你胖了什么的 你别在意，我下次也不会说啦，怪我，不过我会尽量缩短我在单位的工作时间早点回来陪你跑步，直到让你对自己身材满意为止，我会陪着你的！！！</p><p>陈晨，我不是一个爱说以后的人，因为说以后真的是一个笑话，我只能说，当下我会好好的爱你，对你加倍的好，也会包容你的小脾气，每周都会给你做好吃的，带你去你想去的地方，我会好好努力，挣钱养你和我妈~相信我，当然我可能也会有点小脾气，也有很多的缺点，但是你一定要及时的提出来啦，你提的我都为了咱们去改！相信我！</p><p>最后，今天是个特殊的日子，我要大声的说</p><h1 id="陈晨，我爱-你！！！！让我们一直这样的幸福下去！"><a href="#陈晨，我爱-你！！！！让我们一直这样的幸福下去！" class="headerlink" title="陈晨，我爱~你！！！！让我们一直这样的幸福下去！"></a>陈晨，我<del>爱</del>~你！！！！让我们一直这样的幸福下去！</h1><p><img src="/static/langman.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相信我！&quot;&gt;&lt;a href=&quot;#相信我！&quot; class=&quot;headerlink&quot; title=&quot;相信我！&quot;&gt;&lt;/a&gt;相信我！&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node环境变量配置</title>
    <link href="http://yoursite.com/2018/05/16/node%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/16/node环境变量配置/</id>
    <published>2018-05-16T13:40:23.000Z</published>
    <updated>2018-05-17T01:50:00.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个环境变量实在是有点坑，前面倒腾了几次，还是有问题，现在这个问题终于解决了，我来阐述下我的配置及踩过的坑</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><pre><code>vue -V 不是内部命令node -v 不是内部命令npm -v 不是内部命令等</code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>出现以上场景都是因为你的npm路径有问题，所以导致不是命令，接下来将会配置npm</p><pre><code>1. 指定npm全局路径 </code></pre><p>我会在E盘创建nodejs文件目录，在下面分别创建node_global和node_cache文件夹</p><pre><code>2. 命令npm config set prefix &quot;d:\nodejs\node_global&quot;npm config set prefix &quot;d:\nodejs\node_cache&quot;</code></pre><p>以上命令指定npm的路径为刚刚创建的文件路径<br>    3.配置环境变量<br>环境变量分为系统变量和用户变量<br>    系统变量中新建变量名：NODE_PATH，变量值：D:\nodejs\node_global\node_modules<br>    路径还是刚刚创建时的路径<br>    用户变量中的PATH中添加：D:\nodejs\node_global</p><p>一定记得 不要在系统变量中的PATH去写，我之前就是踩的这个深坑，怎么找都找不出来，加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个环境变量实在是有点坑，前面倒腾了几次，还是有问题，现在这个问题终于解决了，我来阐述下我的配置及踩过的坑&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手机select展示样式不同</title>
    <link href="http://yoursite.com/2018/05/16/%E6%89%8B%E6%9C%BAselect%E5%B1%95%E7%A4%BA%E6%A0%B7%E5%BC%8F%E4%B8%8D%E5%90%8C/"/>
    <id>http://yoursite.com/2018/05/16/手机select展示样式不同/</id>
    <published>2018-05-16T13:32:37.000Z</published>
    <updated>2018-05-21T11:18:54.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><p>虽然今天心情不好，但是也算是学到了点东西</p><p>select在手机当中展示的样式不同，所以，为了还原UI，需要按照UI样式写</p><pre><code>将select下拉框使用定位盖在UI上面，透明度给0就可以实现，通过change事件的改变在来改变UI的DOM，此方法为最合适的方法</code></pre><p>一定要注意变通，而且不管干什么一定要注意过脑子</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下拉框&quot;&gt;&lt;a href=&quot;#下拉框&quot; class=&quot;headerlink&quot; title=&quot;下拉框&quot;&gt;&lt;/a&gt;下拉框&lt;/h3&gt;&lt;p&gt;虽然今天心情不好，但是也算是学到了点东西&lt;/p&gt;
&lt;p&gt;select在手机当中展示的样式不同，所以，为了还原UI，需要按照UI样式写
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>换电脑后如何继续写博客</title>
    <link href="http://yoursite.com/2018/04/27/%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/04/27/换电脑后如何继续写博客/</id>
    <published>2018-04-27T13:26:48.000Z</published>
    <updated>2018-05-16T13:25:59.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为有写博客的习惯，但是公司的事儿太忙了，耽搁了好久，每次回家都挺累，所以决定还是每天在公司写一篇博客吧，其实倒是有点像是日记了，不过对于每天的总结还是很有帮助的，blog文章命名一定要以功能来进行命名，这样在以后如果有类似的话很好找</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>传送门</strong> <a href="https://blog.csdn.net/eternity1118_/article/details/71194395?ref=myread" target="_blank" rel="noopener">换电脑后如何继续写博客</a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>1.找到你原来写blog的文件夹，找到<strong>_config.yml</strong>、<strong>themes</strong>、<strong>source</strong>、<strong>scaffolds</strong>、<strong>package.json</strong></p><p>2.copy到你本地  例： /hexo文件中</p><h5 id="下载hexo"><a href="#下载hexo" class="headerlink" title="下载hexo"></a>下载hexo</h5><pre><code>npm install hexo -g   </code></pre><h5 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h5><pre><code>npm install  npm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save</code></pre><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><pre><code>hexo ghexo deploy</code></pre><h3 id="加油，你不是最弱的"><a href="#加油，你不是最弱的" class="headerlink" title="加油，你不是最弱的"></a>加油，你不是最弱的</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为有写博客的习惯，但是公司的事儿太忙了，耽搁了好久，每次回家都挺累，所以决定还是每天在公司写一篇博客吧，其实倒是有点像是日记了，不过对于每
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-04-27 小组会</title>
    <link href="http://yoursite.com/2018/04/27/2018-04-27-%E5%B0%8F%E7%BB%84%E4%BC%9A/"/>
    <id>http://yoursite.com/2018/04/27/2018-04-27-小组会/</id>
    <published>2018-04-27T12:58:01.000Z</published>
    <updated>2018-04-27T13:32:46.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>来了快两个月了，因为平时比较忙，大家都比较忙，距离上次开会大概是三周前了</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>不足之处</p><pre><code>1. 针对于现在h5移动端调试问题只能使用手机终端进行调试，影响效率</code></pre><p>答： 因为需要与客户端交互，需要客户端的数据，暂时只能使用抓包工具在store当中把数据先写死进行调试</p><pre><code>2. 命名规范问题</code></pre><p>答： css遵从BEM规范进行命名</p><pre><code>3. git规范开发流程</code></pre><p>答： 首先，环境有dev(本地测试)、alpha(测试人员测试)、rc(预上线测试人员测试)、pro(正式环境)<br>git开发分支：本地创建feature/projuct  ==&gt;  提测合并alpha分支（发送邮件）  ==&gt;  测试通过合并develop分支 ==&gt;  develop分支合并至rc分支并且删除本地分支，如果有bug从rc拉取bugfix/bug分支（develop分支为一个中转站 发送邮件）  ==&gt;  测试通过合并至pro分支（在测试的邮件中回复全部发送运维）<br>需要注意的是邮件的<strong>准确性</strong></p><pre><code>4. .vue单文件组件命名方式</code></pre><p>答： 该文件命名规范为大驼峰例：List.vue BaseInfo.vue</p><p>老大说的几句话挺对的</p><pre><code>1. 设计简单合理2. UI设计，审美观念3. 提高自我价值，变强4. 愿意接受改变，接受别人的建议5. 当封装公共组件时，最好大家一起讨论下设计思想，能够减少返工时间，提高开发效率</code></pre><p>在设计的时候最好有至少两种的设计理念，并且当拿到需求时，一定要先自己设计一遍，不要埋头就干，不过我对着这个还是有满满的自信的，对于审美方面，也许是我自己太死板了，没有用心，没有把自己当成一个客户，可能比较随意，这点我会改正，加油吧！！！</p><h3 id="不管如何，你都要去克服，去接受，把它变为自己的"><a href="#不管如何，你都要去克服，去接受，把它变为自己的" class="headerlink" title="不管如何，你都要去克服，去接受，把它变为自己的"></a>不管如何，你都要去克服，去接受，把它变为自己的</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;来了快两个月了，因为平时比较忙，大家都比较忙，距离上次开会大概是三周前了&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间戳转换年月日小月问题</title>
    <link href="http://yoursite.com/2018/04/22/%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%B9%B4%E6%9C%88%E6%97%A5%E5%B0%8F%E6%9C%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/22/时间戳转换年月日小月问题/</id>
    <published>2018-04-22T11:55:43.000Z</published>
    <updated>2018-04-22T12:21:21.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从今天开始，更新文章只针对于功能块进行更新，可能一次几个标题，这样能够在后面的日子中可以找到相关问题，规范一下</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>针对于时间转换的问题在工作当中可是用的很多的，比如这次的时间需求，1.##格式正确##，2.##结束时间不能大于开始时间##，3.##有效时间##</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>new Date(‘2017/02/02 00:00:00’)</p><p>对于这种时间 我是将格式放入new Date当中进行装换，这样的话问题1，2都可解决，对于问题三就是今天得重点</p><p>大家都知道有大小月，问题在于用这个转换小月的话还是会合法，比如2018/02/31</p><p><img src="/static/04-22-1.png" alt="img"></p><p>大家看到问题了吧，对！就是在小月31日时也是合法，但是会转换为别的日期</p><p>解决，在转换前和转换后进行对比就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;从今天开始，更新文章只针对于功能块进行更新，可能一次几个标题，这样能够在后面的日子中可以找到相关问题，规范一下&lt;/p&gt;
&lt;h3 id=&quot;需求
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阿西吧</title>
    <link href="http://yoursite.com/2018/04/15/%E9%98%BF%E8%A5%BF%E5%90%A7/"/>
    <id>http://yoursite.com/2018/04/15/阿西吧/</id>
    <published>2018-04-15T12:06:56.000Z</published>
    <updated>2018-04-15T12:35:58.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知不觉的，已经一个月没有更新了，最近工作真的很忙，简直没有时间，不过，在这段时间内，老大对于我的纠正，我也学会了很多的东西，比如element UI算是熟悉了，对于Jquery的操作也基本都会了（以前真的没怎么用过），主要来说，我的问题还是在命名规范的上面，简直被老大喷的不要不要的，不过老大对我很好，每次都是好好的说，对于前端UI上面的设计也算是有点体会了。</p><h3 id="Element-form自带验证"><a href="#Element-form自带验证" class="headerlink" title="Element form自带验证"></a>Element form自带验证</h3><p>刚开始解除，对于这种验证格式真的没有解除过，导致返工了很多的东西，Element 对于 form表单验证做的还是比较的齐全的</p><p><img src="/static/04-15-1.png" alt="img"></p><p>引入各种就不多说了现在只说下用法</p><p><el-form :rules="rules" ref="form" :model="ruleForm"></el-form></p><p>:model 表单数据对象<br>:rules 表单验证规则<br>ref 需要调用Element 封装的内部方法</p><p>以上三者为必须！</p><p>model 就是你data里面需要初始化的值</p><p>eg:ruleForm: {<br>          name: ‘’,<br>        }</p><p>在v-model当中写入对应的即可<br>rules 验证方式分为两种，一种为行内，一种写在data当中</p><p><strong>行内</strong><br>    <el-form-item prop="name" rules="[        { required: true, message: '请输入姓名', trigger: 'blur' },    ]"></el-form-item><br>其中，required为必填项,也就是左边那个##*##样式</p><p><strong>data中定义</strong></p><pre><code>data () {    return {        rules:{            name: { type: &apos;String&apos;, required: true, message: &apos;请选择名称&apos;, trigger: &apos;blur&apos; }        }    }}</code></pre><p>以上为rules的定义规则</p><p>这里还要说一下自定义验证<br>    data () {<br>        var nameVerification = function (rule, value, callback) {<br>            // 业务逻辑</p><pre><code>        value 失去焦点的值        callback 一定要记住，不管你的验证是否通过都必须有callback调用，否则在点击确定按钮将会无效！！！！    }     return {        rules:{             name: { validator: nameVerification, trigger: &apos;blur&apos; }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;不知不觉的，已经一个月没有更新了，最近工作真的很忙，简直没有时间，不过，在这段时间内，老大对于我的纠正，我也学会了很多的东西，比如eleme
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git日常基本指令</title>
    <link href="http://yoursite.com/2018/03/14/git%E6%97%A5%E5%B8%B8%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/14/git日常基本指令/</id>
    <published>2018-03-14T05:33:33.000Z</published>
    <updated>2018-03-14T05:50:09.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好久没有更新了，这段时间也忙也闲，金三银四，大家都在各自的公司因为各种原因都在进行着面试，我也一样，上周收到了offer，这周就赶紧进行交接，心情也还不错，可惜就是我的团队我很不舍得离开，大家都对我很好，哎，好不舍，但是现实就是这样，没有不散的宴席，大家加油吧，我相信你们会更好的！</p><p><img src="http://img1.imgtn.bdimg.com/it/u=2417507986,147620643&amp;fm=27&amp;gp=0.jpg" alt="img"></p><a id="more"></a><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>对于现在的协同开发者工具<strong>Git</strong>、<strong>SVN</strong>大家应该都已经很熟悉了，当然，现在还是Git使用的更多一些，并且也有很多的优势，安装什么的就不说，只是简单的复习一下简单的命令，不喜勿喷</p><pre><code>git add .               提交全部文件git commit -m &quot;注释&quot;    提交到本地git pull                拉取代码，解决冲突git add .git commit -m &quot;注释&quot;git push                进行远程推送的仓库当中git push origin 分支名  也可完成推送</code></pre><p>这是简单的提交</p><p>创建分支</p><pre><code>git checkout -b &quot;分知名&quot;git push origin &quot;创建的分知名&quot;    推送到远端</code></pre><p>查看分支</p><pre><code>git branch</code></pre><p>合并分支</p><pre><code>git merge 分支名</code></pre><p>注：合并分支后先进行解决冲突</p><p>查看日志</p><pre><code>git log         查看全部日志git log -p      查看已提交详情的修改git log -p -2   查看最近两次的详情修改</code></pre><p>回退版本</p><pre><code>git reset --hard 版本号</code></pre><p>注：在这里回退的版本后，使用git log 只能打印到你回退版本的时间记录处，所以，大家一定要做好备份！！！！！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;好久没有更新了，这段时间也忙也闲，金三银四，大家都在各自的公司因为各种原因都在进行着面试，我也一样，上周收到了offer，这周就赶紧进行交接，心情也还不错，可惜就是我的团队我很不舍得离开，大家都对我很好，哎，好不舍，但是现实就是这样，没有不散的宴席，大家加油吧，我相信你们会更好的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.imgtn.bdimg.com/it/u=2417507986,147620643&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈原型链 prototype __proto__</title>
    <link href="http://yoursite.com/2018/03/03/%E6%B5%85%E8%B0%88%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype-proto/"/>
    <id>http://yoursite.com/2018/03/03/浅谈原型链-prototype-proto/</id>
    <published>2018-03-03T03:16:01.000Z</published>
    <updated>2018-03-03T04:06:59.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>hi，这两天都比较忙，好不容易有点时间立刻就来更新啦~，因为项目都是由Vue进行开发的，一直想看看源码，但是又限于自己的原因，所以先来对面向对象来总结总结！~</p><p><img src="http://img5.imgtn.bdimg.com/it/u=2822639283,850849670&amp;fm=11&amp;gp=0.jpg" alt="img"></p><a id="more"></a><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>相信大家对于对象来说都很熟悉了，在js当中万物皆对象嘛！</p><p>对于prototype大家都知道，每一个函数都会有一个prototype属性，但是<strong>proto</strong>是个什么呢？</p><p>请看下面一段代码</p><pre><code>let obj = {};obj.prototype.a = function(){       //解析到这会报错,实例中是无法使用prototype}obj.a();</code></pre><p><img src="/static/o1.png" alt="img"></p><p>为什么呢？ 因为prototype是只有函数拥有的属性，在对象实例中是无法使用的，那如何实现呢？</p><pre><code>function Man(height){    this.height = height}let obj = new Man(178);Man.prototype.a = function(){    alert(this.height)}obj.a();</code></pre><p>代码运行正常</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>每一个对象都拥有<strong>proto</strong>属性，这个属性是用来指向构造函数的prototype的<br>每一个函数都拥有prototype属性，通过<strong>proto</strong>来指向prototype来实现<strong>继承</strong><br>每一个函数都拥有constructor属性，指向所有原型实例的构造函数</p><p>找一个实例的属性 会进行递归操作：</p><p>实例属性 =&gt; __proto =&gt; 实例属性构造函数的prototype =&gt; obj.prototype 为止</p><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><p><img src="https://segmentfault.com/img/bVT7ae?w=423&amp;h=513" alt="img"></p><p>暂时更新这么多啦，一起加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;hi，这两天都比较忙，好不容易有点时间立刻就来更新啦~，因为项目都是由Vue进行开发的，一直想看看源码，但是又限于自己的原因，所以先来对面向对象来总结总结！~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img5.imgtn.bdimg.com/it/u=2822639283,850849670&amp;amp;fm=11&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>flex布局 移动端布局利器</title>
    <link href="http://yoursite.com/2018/02/26/flex%E5%B8%83%E5%B1%80-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%88%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2018/02/26/flex布局-移动端布局利器/</id>
    <published>2018-02-26T12:09:49.000Z</published>
    <updated>2018-02-26T14:13:04.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名前端开发人员，不仅要有睿智的大脑，更要想办法去提高工作效率，在传统布局中<strong>float</strong>、<strong>display:inline-block</strong>，使用后是不是总感觉要么向上多一点，要么向下多一点，还要使用margin或者padding来进行调，不然总感觉怪怪的！</p><p><img src="http://img5.imgtn.bdimg.com/it/u=2212265039,2568628666&amp;fm=27&amp;gp=0.jpg" alt="img"></p><p>哈哈哈，进入正题！<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">Flex 布局教程:语法篇 - 阮一峰的网络日志</a></p><h3 id="简介flex"><a href="#简介flex" class="headerlink" title="简介flex"></a>简介flex</h3><p>flex布局是W3C提出的一种新型的布局方案，目前大部分浏览器都支持，但是仍然有兼容性问题，但是对于H5开发工程师来说，这不是个问题，因为基于chrome内核,当然，也需要添加display:-webkit-flex;</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="img"></p><p>在传统布局中，水平方向<strong>块</strong>使用<font color="red">margin: 0 auto</font> | <font color="aqua">left:50% transform:translateX(-50%)</font>实现，<strong>行内</strong><font color="aqua">text-align:center</font>即可实现，可是对于垂直居中实现就比较麻烦</p><p>flex是Flexible Box的缩写，意为”弹性布局”,提供该盒子提供更大的灵活度。</p><p>任何一个容器都可以使用flex,谷歌内核必须添加-webkit-</p><pre><code>.box{    display:-webkit-flex;    display:flex;}</code></pre><h3 id="flex基本介绍"><a href="#flex基本介绍" class="headerlink" title="flex基本介绍"></a>flex基本介绍</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li>flex-direction</li><li>flex-wrap</li><li>justify-content</li><li>align-items</li><li>align-content</li><li>flex-flow</li></ul><font size="5">一、flex-direction(主轴)</font><p>在容器内，决定水平方向的排列</p><pre><code>1. flex-direction:row;左 =&gt; 右</code></pre><p><img src="/static/flx1.png" alt="img"></p><pre><code>2. flex-direction:row-reverse;右 =&gt; 左</code></pre><p><img src="/static/flex2.png" alt="img"></p><pre><code>3. flex-direction:column;上 =&gt; 下</code></pre><p><img src="/static/flex3.png" alt="img"></p><pre><code>4. flex-direction:column-reverse;下 =&gt; 上</code></pre><p><img src="/static/flex4.png" alt="img"></p><font size="5">二、flex-wrap(主轴)</font> <p>在容器内，决定水平方向是否换行</p><pre><code>1.flex-wrap:nowrap;不换行</code></pre><p><img src="/static/flex5.png" alt="img"></p><pre><code>2.flex-wrap:wrap;换行</code></pre><p><img src="/static/flex6.png" alt="img"></p><pre><code>3.flex-wrap:wrap-reverse;换行换位</code></pre><p><img src="/static/flex7.png" alt="img"></p><font size="5">三、justify-content(主轴)</font> <p>在容器内，决定水平方向的对齐方式</p><pre><code>1.justify-content:flex-start;在主轴开始位置对齐</code></pre><p><img src="/static/flex8.png" alt="img"></p><pre><code>2.justify-content:flex-end;在主轴结束位置对齐</code></pre><p><img src="/static/flex9.png" alt="img"></p><pre><code>3.justify-content:center;在主轴居中</code></pre><p><img src="/static/flex10.png" alt="img"></p><pre><code>4.justify-content:space-around;两边空白间隙排列</code></pre><p><img src="/static/flex11.png" alt="img"></p><pre><code>5.justify-content:space-between;无空白居中间隙排列</code></pre><p><img src="/static/flex12.png" alt="img"></p><font size="5">四、align-items(交叉轴)</font> <p>在容器内，决定垂直方向的排列</p><pre><code>1.align-items:flex-start;上</code></pre><p><img src="/static/flex13.png" alt="img"></p><pre><code>2.align-items:flex-end;下</code></pre><p><img src="/static/flex14.png" alt="img"></p><pre><code>3.align-items:center;垂直方向居中</code></pre><p><img src="/static/flex15.png" alt="img"></p><font size="5">四、align-content(交叉轴)</font><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><h3 id="未完，待续-！"><a href="#未完，待续-！" class="headerlink" title="未完，待续~！"></a>未完，待续~！</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;作为一名前端开发人员，不仅要有睿智的大脑，更要想办法去提高工作效率，在传统布局中&lt;strong&gt;float&lt;/strong&gt;、&lt;strong&gt;display:inline-block&lt;/strong&gt;，使用后是不是总感觉要么向上多一点，要么向下多一点，还要使用margin或者padding来进行调，不然总感觉怪怪的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img5.imgtn.bdimg.com/it/u=2212265039,2568628666&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;哈哈哈，进入正题！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端基础算法 冒泡排序 选择排序 快速排序</title>
    <link href="http://yoursite.com/2018/02/24/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/02/24/前端基础算法-冒泡排序-选择排序-快速排序/</id>
    <published>2018-02-24T13:02:53.000Z</published>
    <updated>2018-02-24T14:08:27.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名合格的前端不仅对自身业务能力的要求，还必须具有一定的算法知识，虽然博主数学就没及过格~,但是没办法，还是要学，这不，年前两天没啥事儿，看了看我最头痛的算法，当然，都是基本的，各位同学看到肯定一下就明白了，好了，进入正题~！<br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3305254330,4081387098&amp;fm=27&amp;gp=0.jpg" alt="img"></p><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序算是最基本的了，也是效率最低的，但是他很稳定，对于一些小玩意儿还是可以，先上代码~</p><pre><code>//TODO 冒泡排序//TODO 首先就是两层循环，这样才能够拿一个和所有的值进行比对var item;for(var i=0;i &lt; arr.length;i++){    for(var j=0;j &lt; arr.length - 1 - i;j++){        //TODO 如果当前值大于当前第二个值 进行交换        if(arr[j] &lt; arr[j+1]){            item = arr[j];            arr[j] = arr[j+1];            arr[j+1] = item;        }    }}</code></pre><p>例如:</p><pre><code>var arr = [5,6,3,2,7];第一层5 6             6大    6 3           6大        6 2         6大            6 7       7大现在arr = [5,3,2,6,7]第二层5 3             5大    5 2           5大        5 6         6大现在arr = [3,2,5,6,7]依次类推~</code></pre><p>而且是不是发现循环次数越来越小,那是因为j循环的条件 j &lt; arr.length - 1 - i,当每次循环后，i会++ 所以，循环此时也会减小，提高性能，因为最大数已经排列到后续。</p><pre><code>item = arr[j];arr[j] = arr[j+1];arr[j+1] = item;</code></pre><p>此处为值的交换，使用变量来保存当前值，然后通过索引来找到对应的值进行交换。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>对于选择排序其实与冒泡排序出入并不大，两者都是算法当中的<strong>慢排</strong>，上代码！</p><pre><code>//TODO 选择排序//TODO item 存储值 minIndex 存储索引var item,minIndex;for(var i=0;i &lt; arr.length;i++){    //默认为第0个索引    minIndex = i;    for(var j=i+1;j&lt;arr.length;j++){        //发现比minIndex小，从新进行赋值        if(arr[j] &gt; arr[minIndex]){            minIndex = j;        }    }    //交换值    item = arr[i];    arr[i] = arr[minIndex];    arr[minIndex] = item;}</code></pre><p>不同点：</p><ul><li>冒泡不管是大还是小，都是从后往前排列，而选择排序则不管大小都是从前往后排列，当然，这个根据自己喜好走的，只需要改变条件和初始值即可</li><li>选择排序采用一个变量几率索引来进行控制最小值。</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>听名字就知道很快咯，是算法效率高的一种!</p><pre><code>//TODO 快速排序function biu(arr){    if(arr.length &lt;= 1) return arr    //TODO 获取当前一半下标的位置    let pivotIndex = Math.floor(arr.length/2);    //TODO 通过获取到的位置获取到当下下标位置的值    let pivot = arr.splice(pivotIndex,1)[0];    //TODO 定义好两个数组    let left = [];    let right = [];    for(var i=0;i &lt; arr.length;i++){        if(arr[i] &gt; pivot){            right.push(arr[i])        }else{            left.push(arr[i]);        }    }    return biu(left).concat([pivot],biu(right));}</code></pre><p>快速排序第一次看到也是研究了一下</p><ul><li>找到当前数组中间的下标，获取到对应下标的值</li><li>分别定义left right 数组用于承接<strong>小于小标的值</strong>和<strong>大于下标的值</strong></li><li>通过递归的方式继续上两步，直到符合条件进行return</li></ul><p>例：<br>    var arr = [1,8,2,7,3];</p><p>[1,8,<font color="red">2</font>,7,3]</p><p>[1][<font color="red">2</font>][8,7,3]</p><p>[1][2][8,<font color="red">7</font>,3]</p><p>[1,2,3,7,8]</p><p>拆分在合并 小于拆分值的在左边 大于拆分值的在右边 合并在拆分  一直重复递归，这就是快速排序，算法高效率之一！</p><p>好了，暂时就先介绍对着三种算法的理解，如果有问题的话，希望各位及时反馈给我~！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;作为一名合格的前端不仅对自身业务能力的要求，还必须具有一定的算法知识，虽然博主数学就没及过格~,但是没办法，还是要学，这不，年前两天没啥事儿，看了看我最头痛的算法，当然，都是基本的，各位同学看到肯定一下就明白了，好了，进入正题~！&lt;br&gt;&lt;img src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3305254330,4081387098&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>github配合hexo建站攻略（4）域名与github绑定</title>
    <link href="http://yoursite.com/2018/02/23/github%E9%85%8D%E5%90%88hexo%E5%BB%BA%E7%AB%99%E6%94%BB%E7%95%A5%EF%BC%884%EF%BC%89%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/02/23/github配合hexo建站攻略（4）域名绑定/</id>
    <published>2018-02-23T02:45:31.000Z</published>
    <updated>2018-02-24T14:08:10.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h3><p>域名这玩儿，我申请了几天终于下来了，这不~，趁热打铁，一并写出来与大家一块分享，本人域名<a href="www.hushnow.cn">www.hushnow.cn</a>，望各位大佬捧场，谢谢~~！</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2464799472,2104441980&amp;fm=27&amp;gp=0.jpg" alt="img"></p><p>嗯！<br><a id="more"></a></p><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>首先，你得先去注册个域名不是，看了看网上的大牛，大多都是<a href="https://sg.godaddy.com/zh?isc=gennbacn29&amp;countryview=1&amp;currencytype=CNY&amp;utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=zh-cn_corp_sem_base_brand_bz&amp;utm_content=adgroup+-+20171124&amp;utm_term=Title&amp;mkwid={mediatype}WS66RcZ2_pcrid_{creative}_pdv__" target="_blank" rel="noopener">goDaddy</a>,这是一个新加坡网站，我就在这里购买的域名</p><p>1、注册什么的就不多说了，先去注册</p><p>2、搜一个域名</p><p><img src="/static/41.png" alt="img"></p><p>3、添加至购物车</p><p><img src="/static/42.png" alt="img"></p><p>4、剩下的就是登陆一下，选<strong>goDaddy</strong>是因为他支持支付宝付款，等你付完款后，他会进行实名认证，接下来你就至需要等几天，这个全程只需要关注邮箱即可！</p><h3 id="DNSpod"><a href="#DNSpod" class="headerlink" title="DNSpod"></a>DNSpod</h3><p>在这里我使用的是<strong>DNSpod</strong>来进行管理域名，有以下几点原因：<br>1、域名提供商提供的往往不够稳定。</p><p>2、域名提供商免费提供不的支持多线解析，但dnspod提供，即智能解析。支持网通电信教育国外等多种线路，更是支持分省解析。</p><p>3、域名提供商提供的由于用户众多，解析很慢，但dnspod很快，特别是vip用户，在保证稳定的前提下可以比域名提供商的快10倍以上。</p><p>4、功能的多样化。提供包括宕机检测，分省解析，访问量统计，分组管理，挂马扫描等在内的多种附加服务，保证网站的安全稳定。 5、DNS对大用户来说，影响是十分大的，所以很多网站都用dnspod。</p><p><strong>传送门</strong> <a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSpod</a></p><p>1、 注册不用多说</p><p>2、 先绑定域名，NS是你DNS解析域名，你需要绑定两条A<strong>记录类型</strong>，分别为<strong>@</strong>、<strong>www</strong>，打开cmd，ping 用户名.github.io 然后你会看到ip地址，<strong>记录纸</strong>为你ping 出来的ip地址,下图为我本机的地址</p><p><img src="/static/43.png" alt="img"></p><p>3、 去goDaddy中绑定DNS ，点击我的账户 =&gt; 域名 =&gt; DNS管理</p><p><img src="/static/45.png" alt="img"></p><p>4、 将域名服务器进行更改，改为DNSpod的DNS来进行解析</p><p><img src="/static/44.png" alt="img"></p><p>5、 最后一步，在根目录下的sourse文件中新建CNAME文件，一定要大写，写上你申请的域名，不要加www!<br>eg:</p><pre><code>hushnow.cn</code></pre><p>好了，泡杯咖啡等10分钟再去访问你的域名，是不是很赞劲~~!</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2069975793,865929935&amp;fm=27&amp;gp=0.jpg" alt="img"></p><h4 id="完结！"><a href="#完结！" class="headerlink" title="完结！"></a>完结！</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开场&quot;&gt;&lt;a href=&quot;#开场&quot; class=&quot;headerlink&quot; title=&quot;开场&quot;&gt;&lt;/a&gt;开场&lt;/h3&gt;&lt;p&gt;域名这玩儿，我申请了几天终于下来了，这不~，趁热打铁，一并写出来与大家一块分享，本人域名&lt;a href=&quot;www.hushnow.cn&quot;&gt;www.hushnow.cn&lt;/a&gt;，望各位大佬捧场，谢谢~~！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2464799472,2104441980&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗯！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>github配合hexo建站攻略（3）统计访问量</title>
    <link href="http://yoursite.com/2018/02/22/github%E9%85%8D%E5%90%88hexo%E5%BB%BA%E7%AB%99%E6%94%BB%E7%95%A5%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/22/github配合hexo建站攻略（3）/</id>
    <published>2018-02-22T12:27:04.000Z</published>
    <updated>2018-07-04T08:16:50.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="统计访问量的实现？"><a href="#统计访问量的实现？" class="headerlink" title="统计访问量的实现？"></a>统计访问量的实现？</h3><p>上一篇介绍了如何构建一个基本的网站，但是 是网站他就得有访问量不是~？ 不然怎么能满足咱们内心的蠢动，有木有~~！</p><p><img src="http://img5.imgtn.bdimg.com/it/u=3296605248,3911530965&amp;fm=27&amp;gp=0.jpg" alt="img"></p><p>。。。</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.lookk.cn/2017/12/09/hexo-yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">hexo yilia主题添加文章访问量统计</a></p><h3 id="太阳当空照-太阳对我眨眼睛"><a href="#太阳当空照-太阳对我眨眼睛" class="headerlink" title="太阳当空照~太阳对我眨眼睛~"></a>太阳当空照~太阳对我眨眼睛~</h3><p>在一开始的时候，我以为很难，可是呢~其实不难，既然这都是第二篇了，大家肯定跟我一样的想法</p><p>统计访问量有这几种：<strong>百度的站长统计</strong> 、 <strong>leancloud</strong> 、 <strong>不蒜子</strong>;</p><p>根据进行比对，不蒜子要简单很多，因为建站的初衷还是在于写博客，自己安慰自己，把学的东西都进行总结和巩固，所以就先它了~！！</p><p>不过首先声明，我使用的主题为yilia</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><pre><code>&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>该代码可以粘贴至themes/yilia/layout/footer.ejs 或者 header.ejs 或者 left-col.ejs下</p><h3 id="站点访问量显示"><a href="#站点访问量显示" class="headerlink" title="站点访问量显示"></a>站点访问量显示</h3><p>因为这个显示是给人家看的，所以个人认为 放在left-col.ejs下，这样在PC进站时能够看到访问量，但是移动端看不到（正在想处理方法）,你也可以放在footer底部，这样虽然都可以看到，但是必须要看完文章后再能看到，感觉有点不太好</p><pre><code>&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;</code></pre><p>计算访问量的方法有两种：<br>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。<br>我用的是uv的方式，大家自行选择即可。</p><h3 id="添加文章访问量"><a href="#添加文章访问量" class="headerlink" title="添加文章访问量"></a>添加文章访问量</h3><p>文章的访问量显示在文章里面，所以在themes/yilia/layout/article.ejs里加上文章访问量的标签：</p><pre><code>&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code></pre><p>我们直接就这样放在yilia主题中，首页也会显示该网页的访问量，没法正常使用，所以需要一个判断，如果是首页不显示该文章的访问量，下面这段代码添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面：</p><pre><code>&lt;% if ( !index ){ %&gt;        &lt;span class=&quot;archive-article-date&quot;&gt;            阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;        &lt;/span&gt;&lt;% } %&gt;</code></pre><p>这样访问量就都有了，是不是很简单？</p><p><img src="http://img0.imgtn.bdimg.com/it/u=3651943344,1246360666&amp;fm=27&amp;gp=0.jpg" alt="img"></p><h4 id="未完，待续-！"><a href="#未完，待续-！" class="headerlink" title="未完，待续~！"></a>未完，待续~！</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;统计访问量的实现？&quot;&gt;&lt;a href=&quot;#统计访问量的实现？&quot; class=&quot;headerlink&quot; title=&quot;统计访问量的实现？&quot;&gt;&lt;/a&gt;统计访问量的实现？&lt;/h3&gt;&lt;p&gt;上一篇介绍了如何构建一个基本的网站，但是 是网站他就得有访问量不是~？ 不然怎么能满足咱们内心的蠢动，有木有~~！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img5.imgtn.bdimg.com/it/u=3296605248,3911530965&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
