<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-05T09:25:02.718Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>渡丶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>utils</title>
    <link href="http://yoursite.com/2018/10/12/utils/"/>
    <id>http://yoursite.com/2018/10/12/utils/</id>
    <published>2018-10-12T07:46:15.000Z</published>
    <updated>2018-11-05T09:25:02.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h1><h3 id="蓝灯地址，翻墙神器"><a href="#蓝灯地址，翻墙神器" class="headerlink" title="蓝灯地址，翻墙神器"></a>蓝灯地址，翻墙神器</h3><p><a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a></p><a id="more"></a><h3 id="时间过滤器"><a href="#时间过滤器" class="headerlink" title="时间过滤器"></a>时间过滤器</h3><p>format (time, fmt) {<br>    fmt = fmt || ‘yyyy-MM-dd hh:mm’<br>    let date = new Date(time)</p><pre><code>if (/(y+)/.test(fmt)) {    fmt = fmt.replace(        RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)    )}let dt = {    &apos;M+&apos;: date.getMonth() + 1,    &apos;d+&apos;: date.getDate(),    &apos;h+&apos;: date.getHours(),    &apos;m+&apos;: date.getMinutes(),    &apos;s+&apos;: date.getSeconds()}for (let key in dt) {    if (new RegExp(`(${key})`).test(fmt)) {        let str = dt[key] + &apos;&apos;        fmt = fmt.replace(RegExp.$1,            (RegExp.$1.length === 1) ? str : (&apos;00&apos; + str).substr(str.length)        )    }}return fmt</code></pre><p>}</p><h3 id="正则-匹配数字-和-英文逗号"><a href="#正则-匹配数字-和-英文逗号" class="headerlink" title="正则 匹配数字 和 英文逗号"></a>正则 匹配数字 和 英文逗号</h3><p>/[^\d\,]/g</p><h3 id="过滤对象空字符"><a href="#过滤对象空字符" class="headerlink" title="过滤对象空字符"></a>过滤对象空字符</h3><p>// 过滤为空的字段<br>filterData (data) {<br>    for (const key in data) {<br>        if (data[key] === ‘’ || data[key] === undefined) {<br>            delete data[key]<br>        }<br>    }<br>    return data<br>}</p><h3 id="getcomputedStyle-获取最终样式，当获取为translate3d-时，返回的是矩阵，-解析方法"><a href="#getcomputedStyle-获取最终样式，当获取为translate3d-时，返回的是矩阵，-解析方法" class="headerlink" title="getcomputedStyle() 获取最终样式，当获取为translate3d  时，返回的是矩阵， 解析方法"></a>getcomputedStyle() 获取最终样式，当获取为translate3d  时，返回的是矩阵， 解析方法</h3><p>getTransformByMatrix (translateString) {<br>    var matrix = translateString.match(/matrix(3d)?((.+?))/)<br>    var is3D = matrix &amp;&amp; matrix[1]<br>    if (matrix) {<br>        matrix = matrix[2].split(‘,’)<br>        if (is3D === ‘3d’) { matrix = matrix.slice(12, 15) } else {<br>            matrix.push(0)<br>            matrix = matrix.slice(4, 7)<br>        }<br>    } else {<br>        matrix = [0, 0, 0]<br>    }<br>    var result = {<br>        x: parseFloat(matrix[0]),<br>        y: parseFloat(matrix[1]),<br>        z: parseFloat(matrix[2])<br>    }<br>    return result<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工具库&quot;&gt;&lt;a href=&quot;#工具库&quot; class=&quot;headerlink&quot; title=&quot;工具库&quot;&gt;&lt;/a&gt;工具库&lt;/h1&gt;&lt;h3 id=&quot;蓝灯地址，翻墙神器&quot;&gt;&lt;a href=&quot;#蓝灯地址，翻墙神器&quot; class=&quot;headerlink&quot; title=&quot;蓝灯地址，翻墙神器&quot;&gt;&lt;/a&gt;蓝灯地址，翻墙神器&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/getlantern/lantern&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/getlantern/lantern&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/18/mtj-wx-sdk.config/"/>
    <id>http://yoursite.com/2018/09/18/mtj-wx-sdk.config/</id>
    <published>2018-09-18T12:09:00.417Z</published>
    <updated>2018-09-18T12:09:00.419Z</updated>
    
    <content type="html"><![CDATA[/** * @file 百度移动统计配置文件 */module.exports = {    /**     * 从百度移动统计获取的AppKey     * @type {string}     */    appKey: '',    /**     * 是否获取当前的地理位置、速度     * @type {boolean}     */    getLocation: false};]]></content>
    
    <summary type="html">
    
      
      
        /**
 * @file 百度移动统计配置文件
 */

module.exports = {
    /**
     * 从百度移动统计获取的AppKey
     * @type {string}
     */
    appKey: &#39;&#39;,

    /**
     
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/18/mtj-wx-sdk/"/>
    <id>http://yoursite.com/2018/09/18/mtj-wx-sdk/</id>
    <published>2018-09-18T12:08:42.056Z</published>
    <updated>2018-09-18T12:08:42.137Z</updated>
    
    <content type="html"><![CDATA[!function(){"use strict";var c="1.4.3",a={ns:null,boxjs:null},i={},u={},f={logServerUrl:"https://hmma.baidu.com/mini.gif",maxRequestRetryCount:5,requestRetryFirstDelay:1e3,requestRetryMultiple:4,maxRequestDataLength:204800,maxUint8:255,maxUint32:4294967295,enabledEvents:{app:["show","hide","error"],page:["show","hide","ready"],share:["action","success","fail"],event:"*"},storageKeys:{appId:"mtj_appid",key:"mtj_key",uuid:"mtj_uuid",shareCount:"mtj_scnt"}},o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},l=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var s,c=e[Symbol.iterator]();!(r=(s=c.next()).done)&&(n.push(s.value),!t||n.length!==t);r=!0);}catch(e){a=!0,o=e}finally{try{!r&&c.return&&c.return()}finally{if(a)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},r=function(){return"undefined"!=typeof crypto&&crypto.getRandomValues?crypto.getRandomValues(new Uint32Array(1))[0]:Math.floor(Math.random()*f.maxUint32)},s=function(e,t){return"[object "+t+"]"==={}.toString.call(e)},h=function n(r){return(s(r,"Object")||s(r,"Array"))&&Object.keys(r).forEach(function(e){var t=r[e];s(t,"Object")||s(t,"Array")?r[e]=n(t):r[e]=""+t}),r},p=new Set,d=[],n=0,t=function(e){if(e.data=e.data||{},e.data.v=c,e.data.rqc=++n,t=e.data,!(JSON.stringify(t).length<=f.maxrequestdatalength))return n--,void(e.fail&&e.fail(new="" error("invalid="" data")));var="" t;!function="" t(n){var="" r="1<arguments.length&&void" 0!="=arguments[1]?arguments[1]:f.requestRetryFirstDelay;return" a.ns.request({url:n.url,data:n.data,header:object.assign({"content-type":"application="" json"},n.header),method:n.method||"post",datatype:n.datatype||"json",success:function(e){delete="" n.data.rtc,n.success&&n.success(e)},fail:function(e){n.data.rtc="(n.data.rtc||0)+1,n.data.rtc<=f.maxRequestRetryCount?setTimeout(function(){return" t(n,r*f.requestretrymultiple)},r):(delete="" n.data.rtc,n.fail&&n.fail(e))}})}(e)},y="function(){return" p.has("app.launch")&&p.has("app.show")},g="function(){d.forEach(function(e){e.data=Object.assign({},i,e.data),"show"!==e.data.en&&"share"!==e.data.et&&"event"!==e.data.et||Object.assign(e.data,u),t(e)}),d.length=0},m={sendRequest:t,trackEvent:function(e){var" t="this;if(p.add(e.et+"."+e.en),"app"===e.et&&"launch"===e.en&&y()&&g(),"*"===f.enabledEvents[e.et]||-1!==f.enabledEvents[e.et].indexOf(e.en)){e.rid=r(),e.aso=e.aso||{};var" n="{url:f.logServerUrl,dataType:"string",data:Object.assign({},i,e),fail:function(e){return" t.trackerror("sendrequest",e)}};y()?(this.sendrequest(n),"app"="==e.et&&"show"===e.en&&g()):(i.path&&(n.data.path=i.path),i.query&&(n.data.query=i.query),"app"===e.et&&"show"===e.en?d.unshift(n):d.push(n))}},trackError:function(e,t){var" a.ns.getstoragesync(e)}catch(e){m.trackerror("getstoragesync",e)}},s="function(e,t){try{a.ns.setStorageSync(e,t)}catch(e){m.trackError("setStorageSync",e)}},b=function(){return" promise.resolve().then(function(){return="" new="" promise(function(e,t){var="" e(n);n="([1e7]+1e3+4e3+8e3+1e11).replace(/[018]/g,function(e){return(e^("undefined"!=typeof" crypto&&crypto.getrandomvalues?crypto.getrandomvalues(new="" uint8array(1))[0]:math.floor(math.random()*f.maxuint8))&15="">>e/4).toString(16)}),S(f.storageKeys.uuid,n),e(n)})})},k=function(n){return Promise.resolve().then(function(){return new Promise(function(t,e){if(!n)return t();try{a.ns.getShareInfo({shareTicket:n,success:function(e){delete e.errMsg,t(e)},fail:function(e){t({})}})}catch(e){m.trackError("getShareInfo",e),t({})}})})},w={onLaunch:function(){var e=require("./mtj-wx-sdk.config");return e.appKey?(i.key=e.appKey,Promise.all([b(),Promise.resolve().then(function(){return new Promise(function(t,e){try{a.ns.getSetting({success:function(e){e.authSetting&&e.authSetting["scope.userInfo"]?a.ns.checkSession({success:function(e){e&&!1===e.result?t({}):a.ns.getUserInfo({success:function(e){delete e.userInfo.errMsg,t(e.userInfo)},fail:function(){t({})}})},fail:function(){t({})}}):t({})},fail:function(){t({})}})}catch(e){m.trackError("getUserInfo",e),t({})}})}),Promise.resolve().then(function(){return new Promise(function(t,e){try{a.ns.getSystemInfo({success:function(e){delete e.errMsg,t(e)},fail:function(e){t({})}})}catch(e){m.trackError("getSystemInfo",e),t({})}})}),Promise.resolve().then(function(){return new Promise(function(t,e){try{a.ns.getNetworkType({success:function(e){delete e.errMsg,t(e)},fail:function(e){t({})}})}catch(e){m.trackError("getNetworkType",e),t({})}})}),e.getLocation?Promise.resolve().then(function(){return new Promise(function(t,e){try{a.ns.getLocation({type:"wgs84",success:function(e){delete e.errMsg,t(e)},fail:function(e){t({})}})}catch(e){m.trackError("getLocation",e),t({})}})}):Promise.resolve()]).then(function(e){var t=l(e,5),n=t[0],r=t[1],a=t[2],o=t[3],s=t[4];i.uuid=n,u.user=h(r),u.system=h(a),u.network=h(o),s&&(u.location=h(s)),"devtools"===a.platform&&f.latestVersion&&function(e,t){for(var n=e.split("."),r=t.split("."),a=0;a</=f.maxrequestdatalength))return>]]></content>
    
    <summary type="html">
    
      
      
        !function(){&quot;use strict&quot;;var c=&quot;1.4.3&quot;,a={ns:null,boxjs:null},i={},u={},f={logServerUrl:&quot;https://hmma.baidu.com/mini.gif&quot;,maxRequestRetryCou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阅读源码之swiper(一)</title>
    <link href="http://yoursite.com/2018/08/23/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8Bswiper-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/23/阅读源码之swiper-一/</id>
    <published>2018-08-23T07:56:32.000Z</published>
    <updated>2018-08-23T11:28:35.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前就想着阅读源码，但是看到密密麻麻几千行代码的时候，我甚至不知道该从何下手，所以也就放弃了，但是中途有好几次有这种想法的时候，但是没能坚持下去，在我看了视频以及百度后，发现原来我的方法是有问题的，我就是扣的太细，整体的一个架构都不是很了解，所以也就慢慢的坚持不下去了<br><a id="more"></a><br>今天，我再次鼓足勇气来进行阅读源码，因为大神们说话，最能提高自身能力得就是阅读源码，看看别人写代码的风格以及作者的思路，可以累积很多的知识，并且，如果你想要高薪，想要进阶，这是每个高级程序员必走的一条路，所以，我必须要努力，因为什么 你自己心里明白</p><h3 id="选择？"><a href="#选择？" class="headerlink" title="选择？"></a>选择？</h3><p>为什么要选择swiper，原因在于该框架具备的能力能高，也就是，阅读它，不仅能让你对设计架构能力得提升，同时对于动画的理解也有很大帮助，所以，他只是第一步，不管如何，我必须要去征服她，为了她，以及她，我都必须的努力下去，加油吧，少年！！！</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>首先不能继续在范我原来的错误，一定要先粗读一遍，把整体架构分析出来，对于业务也一定要熟悉，了解做的当时写这个情况，为什么会这么写</p><ol><li>项目的整体架构，各个模块的功能</li><li>一定要先把代码都删掉，然后一点一点的添加来进行阅读</li><li>遇到不会的，百度</li><li>断点追踪</li></ol><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><pre><code>/*    typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos;    判断是否为common.js环境中运行，比如Nodejs，则使用module.exports 导出    typeof define === &apos;function&apos;    define 为AMD规范中的函数，判断该函数是否存在，如果存在，则处于AMD运行环境中，define.amd 也是AMD函数，则带入函数中 define(...)    如果以上环境都不存在，说明运行在浏览器中，给window添加该全局对象*/(function (global, factory){    typeof exports === &quot;Object&quot; &amp;&amp; typeof module !== &quot;undefined&quot; ? module.exports = factory() :     typeof define === &quot;function&quot; &amp;&amp; define.amd ? define(factory) :     (window.Swiper = factory())}(this, function() {    var swiper = {}    // ...  //业务逻辑    return swiper}))</code></pre><p>这样做的用处就是 无论是commonjs  还是  AMD  或  seaJS 都可以运行</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前就想着阅读源码，但是看到密密麻麻几千行代码的时候，我甚至不知道该从何下手，所以也就放弃了，但是中途有好几次有这种想法的时候，但是没能坚持下去，在我看了视频以及百度后，发现原来我的方法是有问题的，我就是扣的太细，整体的一个架构都不是很了解，所以也就慢慢的坚持不下去了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自己对自己说的话</title>
    <link href="http://yoursite.com/2018/08/08/%E8%87%AA%E5%B7%B1%E5%AF%B9%E8%87%AA%E5%B7%B1%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
    <id>http://yoursite.com/2018/08/08/自己对自己说的话/</id>
    <published>2018-08-08T02:14:59.000Z</published>
    <updated>2018-08-08T02:36:07.573Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>很久没有写过自己的心里事儿了，这个博客也是相对于自己的，所以不存在公开的问题</p><p>越长大，越孤单到时一点也没有错，渐渐的开始为以后着想，渐渐的开始为以后考虑，不再是只顾着玩儿的那个小孩了</p><p>人生就是减法，吃一顿少一顿，见一面少一面，大家都在忙</p><p>我呢，也一直在努力，就是想让以后的生活会好点，说实话，我的家庭很不好，我打小就从来没有想过来依靠他们，当然，也没啥可以能依靠的，有时候甚至在想他们真的很不负责任，当时为什么要生我，可能当时没有想过以后吧</p><p>有时候听到别人说人家家庭挺好的时候，心里略闪过一丝不爽，可是心里一想，那也是他家的，不是他挣来了，总是这样来安慰自己，但是到了真正用钱，或者结婚的话，确实很需要，没办法，我是男人，只能自己扛吧</p><p>在我北漂的日子里，说实话，我过得很好，周围人都挺好，不管每天工作的多晚，总能学到很多的东西，充实自己</p><p>在抖音上看到一句话，我努力赚钱只是为了<strong>以后不会因为钱来失去些什么东西！</strong>，很现实的一句话，我也会多努力，为了以后能让她幸福</p><p>写这篇文章的目的在于放松下自己，同时给自己前进的动力，加油吧少年，愿一切安好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;很久没有写过自己的心里事儿了，这个博客也是相对于自己的，所以不存在公开的问题&lt;/p&gt;
&lt;p&gt;越长大，越孤单到时一点也没有错，渐渐的开始为以后着想，渐渐的开始为以后考虑，不再是只顾着玩儿的那个小孩了&lt;/p&gt;
&lt;p&gt;人生就是减法，吃一顿少一顿
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自己所遇到过的坑</title>
    <link href="http://yoursite.com/2018/08/08/%E8%87%AA%E5%B7%B1%E6%89%80%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2018/08/08/自己所遇到过的坑/</id>
    <published>2018-08-08T02:12:40.000Z</published>
    <updated>2019-01-16T08:17:25.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总是感觉自己整理的问题有点零散，有时候甚至会再犯，所以写这篇文章的目的是为了能够让自己的记忆更加深刻，同时在遇到以前的问题的时候可以在看看这篇文章</p><a id="more"></a><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="Vue出现偶发赋值不上的问题"><a href="#Vue出现偶发赋值不上的问题" class="headerlink" title="Vue出现偶发赋值不上的问题"></a>Vue出现偶发赋值不上的问题</h3><p>原因：具体还没查到什么原因，有可能视图更新有队列,没赶上<br>解决：将ajax换成同步的可以解决</p><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>router.beforeEach((to, from, next) =&gt; {<br>    to      // 要进入的路由<br>    from    // 要离开的路由<br>    next()  // 方法，必须调用，否则无法进入<br>})<br>router.afterEach() // 用法同上<br>主要是业务逻辑需要，在进入路由前或离开前 需要干点什么事儿</p><p><strong>坑</strong>： 例如判断如果当前用户没有进行登录，跳转至登录页面进行登录</p><pre><code>router.beforeEach((to, from, next) =&gt; {    let token = localStorage.getItem(&apos;getToken&apos;)    if (token) {        next()    } else {        router.push({            path: &apos;/login&apos;        })        next()    }})</code></pre><p>大致一眼看上去没有问题，但是此处缺陷入了死循环</p><p>原因：因为在进入了/login页面时，又进行了触发beforeEach这个方法，next虽然调用，但是依然陷入了死循环当中</p><p>next方法<br><img src="/static/18-08-27.png" alt="img"></p><p>第三条，就是说，只要使用了跳转后，next会进行一个新导航，所以这样才导致了死循环</p><p>解决：</p><pre><code>router.beforeEach((to, from, next) =&gt; {    let token = localStorage.getItem(&apos;getToken&apos;)    if (to.name === &apos;Login&apos; || token) {        next()    } else {        router.push({            path: &apos;/login&apos;        })        next()    }})</code></pre><h3 id="跳转路由标题"><a href="#跳转路由标题" class="headerlink" title="跳转路由标题"></a>跳转路由标题</h3><p>let router = new Router({<br>    mode: ‘history’,<br>    routes: [<br>        {<br>            path: ‘/‘,<br>            meta: {<br>                title: ‘主页’<br>            },<br>            redirect: ‘/login’,      // 重定向<br>        }<br>    ]<br>})<br>这里 主页的标题 可以利用路由守卫来写</p><p>router.beforeEach((to, from, next) =&gt; {<br>    document.title = to.meta.title<br>})</p><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><p>#CSS</p><h3 id="ios下fixed定位失效解决方法"><a href="#ios下fixed定位失效解决方法" class="headerlink" title="ios下fixed定位失效解决方法"></a>ios下fixed定位失效解决方法</h3><p>针对这个问题只能自己做滚动条让中间的一部分来进行滚动</p><h3 id="如何制作滚动条"><a href="#如何制作滚动条" class="headerlink" title="如何制作滚动条"></a>如何制作滚动条</h3><p>解决：overflow-y: scroll</p><h3 id="ios下滚动条卡顿"><a href="#ios下滚动条卡顿" class="headerlink" title="ios下滚动条卡顿"></a>ios下滚动条卡顿</h3><p>自己做的滚动条在ios下会有卡顿问题<br>解决：-webkit-overflow-scrolling: touch     给滚动条元素</p><h3 id="如何隐藏滚动条"><a href="#如何隐藏滚动条" class="headerlink" title="如何隐藏滚动条"></a>如何隐藏滚动条</h3><p>因为在加了-webkit-overflow-scrolling: touch 属性后，隐藏滚动条的css会失效，只能另想他法<br>解决：父级overflow:hidden<br>让滚动条里面的高度/宽度超出父级，这样就可以隐藏滚动条</p><h3 id="ios下吸顶效果"><a href="#ios下吸顶效果" class="headerlink" title="ios下吸顶效果"></a>ios下吸顶效果</h3><p>ios不支持fixed定位，按照之前的套路，scroll事件监听scrollTop =&gt; 获取元素的offsetTop =&gt; scrollTop &gt; offsetTop 改为fixed定位<br>解决：<br>position: sticky;<br>position: -webkit-sticky;</p><p>粘性定位，滚动条未滚动到该元素时，absolute,当滚动过指定元素时,为fixed，ios对于这个属性还是支持的，虽然为从DOM上看是fixed，但是管用</p><h3 id="虚拟键盘挡住输入框"><a href="#虚拟键盘挡住输入框" class="headerlink" title="虚拟键盘挡住输入框"></a>虚拟键盘挡住输入框</h3><p>android系统上，获取焦点后弹出虚拟键盘会挡住输入框，个人猜测，他是先不占用空间，在弹出后占用当前空间<br>解决：setTimeOut(() =&gt; {<br>    document.scrollTop = 元素.offsetTop - 50<br>},500)<br>-50的目的在于不至于贴到顶部</p><h3 id="textarea-实现自适应"><a href="#textarea-实现自适应" class="headerlink" title="textarea 实现自适应"></a>textarea 实现自适应</h3><ol><li><p><div contenteditable="true"></div><br>问题：在ios有兼容性问题</p></li><li><p>js 解决</p></li></ol><p>角色：input事件，scrollHeight 获取当前滚动条高度</p><p>在input事件中，在每次输入时获取到textarea滚动高度，让其height 等于 scrollHeight + ‘px’，记住 前面一定要加height: auto 这个属性，否则你加了高度后高度回不去了</p><p>el.style.height = ‘auto’<br>el.style.height = el.scrollHeight + ‘px’</p><h3 id="获取最终css样式"><a href="#获取最终css样式" class="headerlink" title="获取最终css样式"></a>获取最终css样式</h3><p>// 这两者有兼容性问题，currentStyle 兼容IE  getComputedStyle() 兼容谷歌火狐等….<br>el.currentStyle[‘height’]  </p><p>getComputedStyle(el, null).height</p><h3 id="css-显示省略号打包坑"><a href="#css-显示省略号打包坑" class="headerlink" title="css 显示省略号打包坑"></a>css 显示省略号打包坑</h3><p>webkit-box-orient 在打包后会丢失该属性   optimize-css-assets-webpack-plugin这个插件的问题</p><p>解决方案1：<br>    /<em>! autoprefixer: off </em>/<br>    -webkit-box-orient: vertical;<br>    /<em> autoprefixer: on </em>/<br>解决方案2</p><ol start="2"><li><p>optimize-css-assets-webpack-plugin 从这个插件的问题源头解决</p><p> new OptimizeCSSPlugin({<br> cssProcessorOptions: config.build.productionSourceMap</p><pre><code>? { safe: true, map: { inline: false } }: { safe: true }</code></pre><p> })</p></li></ol><h3 id="移动端-touchmove事件在向右滑动时，会出发ios默认的返回上个页面的事件"><a href="#移动端-touchmove事件在向右滑动时，会出发ios默认的返回上个页面的事件" class="headerlink" title="移动端 touchmove事件在向右滑动时，会出发ios默认的返回上个页面的事件"></a>移动端 touchmove事件在向右滑动时，会出发ios默认的返回上个页面的事件</h3><p>touchmove 阻止事件默认行为</p><h3 id="弹窗问题"><a href="#弹窗问题" class="headerlink" title="弹窗问题"></a>弹窗问题</h3><p>touchmove 禁止默认行为，使其无法滑动，将scrollTop 存在本地，同时将当前元素滚动到0  也就是顶部的位置，当松开后，将记录的scrollTop取出，在滚动到点击浮层的位置</p><p>该方法可解决弹窗滑动问题，但是用户体验稍微差点，会有来回切换的片段，  可在进行研究下</p><p>解决：<br>弹窗打开  禁止body滚动事件  弹窗关闭   解除body滚动事件  </p><pre><code>使用该方法 如果有输入框  在弹起输入框后会有部分ios机型 收起键盘后 底下留白bug解决：离开焦点时让body的scrollTop  =  0         注：滚动条使用的不是body的</code></pre><p>#HTML</p><h3 id="禁止编辑元素-h5属性"><a href="#禁止编辑元素-h5属性" class="headerlink" title="禁止编辑元素  h5属性"></a>禁止编辑元素  h5属性</h3><p>contenteditable=”false”</p><p>#JS</p><h3 id="立即执行函数的写法"><a href="#立即执行函数的写法" class="headerlink" title="立即执行函数的写法"></a>立即执行函数的写法</h3><ol><li>常见写法<br>(function () {</li></ol><p>})()</p><ol start="2"><li>包在里面<br>(function () {</li></ol><p>}())</p><ol start="3"><li>!<br>!function () {</li></ol><p>}()</p><h3 id="浏览器支持事件"><a href="#浏览器支持事件" class="headerlink" title="浏览器支持事件"></a>浏览器支持事件</h3><p>IE6 7 8     attachEvent()<br>主流浏览器   addEventListener()</p><h3 id="如何判断是一个空对象"><a href="#如何判断是一个空对象" class="headerlink" title="如何判断是一个空对象"></a>如何判断是一个空对象</h3><p>解决：</p><ol><li><p>for … in 循环</p></li><li><p>JSON.stringify(obj) === ‘{}’</p></li><li><p>ES6      Object.keys(obj).length &gt; 0</p></li></ol><h3 id="Object-definedProperty-obj-val-descriptor"><a href="#Object-definedProperty-obj-val-descriptor" class="headerlink" title="Object.definedProperty(obj, val, descriptor)"></a>Object.definedProperty(obj, val, descriptor)</h3><p>obj 需要绑定的对象<br>val 对象内的key<br>descriptor  选项参数</p><ol><li>get              当访问该属性触发</li><li>set              当更新该属性触发</li><li>configurable     是否可以删除      默认 true</li><li>enumerable       费否可m<br>#综合问题</li></ol><h3 id="Vue在上线后，针对于不同浏览器没有加载出来页面问题"><a href="#Vue在上线后，针对于不同浏览器没有加载出来页面问题" class="headerlink" title="Vue在上线后，针对于不同浏览器没有加载出来页面问题"></a>Vue在上线后，针对于不同浏览器没有加载出来页面问题</h3><p>原因：有些ES6语法没有被转换成功 new Set map promise asnyc 等<br>解决： cnpm install –save babel-polyfill      </p><h3 id="CORS-跨域解决问题"><a href="#CORS-跨域解决问题" class="headerlink" title="CORS 跨域解决问题"></a>CORS 跨域解决问题</h3><p>原因：跨域问题，一直说CORS来进行解决，缺并不知道怎么来解决<br>解决：在响应头中添加字段<br>    ‘Access-Control-Allow-origin’: ‘*’,             // 都可请求<br>    ‘Access-Control-Allow-Methods’: ‘GET, POST’     // GET、POST方法</p><h3 id="node-中间件"><a href="#node-中间件" class="headerlink" title="node 中间件"></a>node 中间件</h3><p>作用：可以进行统一的配置接口，例如，给所有接口做CORS共享<br>坑：记住 一定要调用next函数，否则无法进行下一步！！！而且报错不提示</p><h3 id="如何获取微信openId"><a href="#如何获取微信openId" class="headerlink" title="如何获取微信openId"></a>如何获取微信openId</h3><pre><code>1. 判断当前域名是否含有code字段2. 有  使用code  3. 没有  请求微信公众号 后台配置的 网页授权安全域名 与  js安全域名一致   返回微信个人信息</code></pre><h3 id="服务器图片转换blob"><a href="#服务器图片转换blob" class="headerlink" title="服务器图片转换blob"></a>服务器图片转换blob</h3><p>发送ajax请求  设置响应类型为blob即可，放入formData中  发送时如果碰见传递参数为空的现象  先看请求头，在看是否为 序列化导致</p><pre><code>handleImage (imgUrl) {    return new Promise((resolve, reject) =&gt; {        let img = imgUrl        if (this.currentHost.includes(&apos;alpha&apos;)) {            if (img.includes(&apos;ztjy-img-dev.szytest.com&apos;)) {                resolve(imgUrl)                return            }        } else {            if (img.includes(&apos;snsimg.ztjystore.cn&apos;)) {                resolve(imgUrl)                return            }        }        var xhr = new XMLHttpRequest()        // 获取二进制对象        xhr.responseType = &apos;blob&apos;        xhr.onload = function () {            // 匹配当前文件后缀            let ext = xhr.getResponseHeader(&apos;Content-Type&apos;).split(&apos;/&apos;)[1]            let formData = new FormData()            formData.append(&apos;file&apos;, xhr.response, Date.now() + &apos;.&apos; + ext)            formData.append(&apos;file_tag&apos;, &apos;ad&apos;)            Articals.upload(formData, res =&gt; {                resolve(res.httpUrl)            }, (errorType, error) =&gt; {                this.$message({type: &apos;error&apos;, message: &apos;操作失败!&apos;})            })        }        xhr.open(&apos;GET&apos;, imgUrl)        xhr.send()    })}</code></pre><h3 id="服务器图片转换blob在通过h5-新属性-转换为base64"><a href="#服务器图片转换blob在通过h5-新属性-转换为base64" class="headerlink" title="服务器图片转换blob在通过h5 新属性 转换为base64"></a>服务器图片转换blob在通过h5 新属性 转换为base64</h3><pre><code>function convertFileToDataURLviaFileReader(url, callback){    var xhr = new XMLHttpRequest();    xhr.responseType = &apos;blob&apos;;    xhr.onload = function() {        var reader  = new FileReader();        reader.onloadend = function () {            callback(reader.result);        }        reader.readAsDataURL(xhr.response);    };    xhr.open(&apos;GET&apos;, url);    xhr.send();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;总是感觉自己整理的问题有点零散，有时候甚至会再犯，所以写这篇文章的目的是为了能够让自己的记忆更加深刻，同时在遇到以前的问题的时候可以在看看这篇文章&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨平台交互神器 DSbridge</title>
    <link href="http://yoursite.com/2018/08/07/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%BA%A4%E4%BA%92%E7%A5%9E%E5%99%A8-DSbridge/"/>
    <id>http://yoursite.com/2018/08/07/跨平台交互神器-DSbridge/</id>
    <published>2018-08-07T09:46:01.000Z</published>
    <updated>2018-08-07T11:55:59.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我在上家公司没怎么与APP交互，但是网上也看了看其他跨平台的插件，确实很麻烦，并且都不支持异步，但是在DSbridge中支持异步调用 是个很好用的跨平台插件</p><a id="more"></a><h3 id="dsbridge"><a href="#dsbridge" class="headerlink" title="dsbridge"></a>dsbridge</h3><ol><li><p>安装依赖</p><p> npm install –save dsbridge</p></li><li><p>在src下创建utils文件夹创建client.js</p></li></ol><p>3.引入dsbridge</p><pre><code>import dsbrige from &apos;dsbridge&apos;</code></pre><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h3 id="dsbrige-call-methods-arg-callback"><a href="#dsbrige-call-methods-arg-callback" class="headerlink" title="dsbrige.call(methods,[arg, callback])"></a>dsbrige.call(methods,[arg, callback])</h3><p>此方法用于调用客户端的方法</p><ol><li><p>methods<br>与客户端定义好的方法，可以是命名空间</p></li><li><p>arg 传递的参数，可选</p></li><li><p>callback 回调函数 可选</p></li></ol><h3 id="dsbridge-register-methods-callback"><a href="#dsbridge-register-methods-callback" class="headerlink" title="dsbridge.register(methods, callback)"></a>dsbridge.register(methods, callback)</h3><p>此方法用于客户端调js的方法 同步方法</p><ol><li><p>methods<br>js定义的方法名</p></li><li><p>回调函数，执行js的逻辑</p></li></ol><h3 id="dsbridge-registersnyc-methods-callback"><a href="#dsbridge-registersnyc-methods-callback" class="headerlink" title="dsbridge.registersnyc(methods, callback)"></a>dsbridge.registersnyc(methods, callback)</h3><p>此方法没有在场景当中用过，不做说明</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我在上家公司没怎么与APP交互，但是网上也看了看其他跨平台的插件，确实很麻烦，并且都不支持异步，但是在DSbridge中支持异步调用 是个很好用的跨平台插件&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS: 伪类 focus-within</title>
    <link href="http://yoursite.com/2018/08/06/CSS-%E4%BC%AA%E7%B1%BB-focus-within/"/>
    <id>http://yoursite.com/2018/08/06/CSS-伪类-focus-within/</id>
    <published>2018-08-06T09:44:53.000Z</published>
    <updated>2018-08-07T09:32:27.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>css确实很强大，能够实现一些js也能完成的特殊功能<br>比如现在要说的表单元素 focus-within属性，这也是我从前端大全公众号里面看到的，大家可以关注下，干货真的很多<br><a id="more"></a><br><a href="https://mp.weixin.qq.com/s/q-OaYqJfm08803-E5PJOhA" target="_blank" rel="noopener">传送门！！！</a></p><h3 id="正主-focus-within"><a href="#正主-focus-within" class="headerlink" title="正主 focus-within"></a>正主 focus-within</h3><p>在上面的连接中，已经详细的介绍了，我就不重复他的话了 我只做一些自己的理解</p><p>首先，该元素只适用于 <strong>表单元素</strong> ,他跟js的冒泡原理一样，一级一级往上冒，也就说 你可以通过这个原理来进行操作同级或者父级元素样式，从而来实现css的各种特效/样式</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;css确实很强大，能够实现一些js也能完成的特殊功能&lt;br&gt;比如现在要说的表单元素 focus-within属性，这也是我从前端大全公众号里面看到的，大家可以关注下，干货真的很多&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滚动顶部或底部出现白色边缘</title>
    <link href="http://yoursite.com/2018/07/31/%E6%BB%9A%E5%8A%A8%E9%A1%B6%E9%83%A8%E6%88%96%E5%BA%95%E9%83%A8%E5%87%BA%E7%8E%B0%E7%99%BD%E8%89%B2%E8%BE%B9%E7%BC%98/"/>
    <id>http://yoursite.com/2018/07/31/滚动顶部或底部出现白色边缘/</id>
    <published>2018-07-31T07:40:05.000Z</published>
    <updated>2018-08-06T09:43:29.284Z</updated>
    
    <content type="html"><![CDATA[<p>###前言</p><p>这是困扰我很久的一个问题<br><a id="more"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>大家都知道，在ios下fixed定位失效问题，为了解决这一问题，必须自己制作滚动条，也就是说比如头部需要固定，把滚动条给内容就好，实际则是内容滚动</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>height:100%<br>overflow-y: scroll<br>给其元素添加这个属性即可</p><p>###彩蛋</p><p>因为ios不支持fixed定位，但如果中间有吸顶效果怎么办？</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>按照一般思路 监听滚动时间scrollTop，当scrollTop &gt; el.offsetTop时 改为fixed定位，否则为absolute</p><p>但是在ios下,滚动事件并不是实时的, 手指滚动 =&gt; 滚动开始 =&gt; 滚动停止 =&gt; 触发事件，所以这个也不靠谱</p><p>position: -webkit-sticky<br>position:sticky     神器属性 需要写兼容</p><p>一定注意，滚动条一定设置overflow-y: scroll 属性</p><p>该粘性定位在滚动时正常滚动，但当滚动条超过时，自动变为固定定位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###前言&lt;/p&gt;
&lt;p&gt;这是困扰我很久的一个问题&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-对象扩展</title>
    <link href="http://yoursite.com/2018/07/09/ES6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/09/ES6-对象扩展/</id>
    <published>2018-07-09T11:45:02.000Z</published>
    <updated>2018-07-31T08:33:27.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a><br><a id="more"></a></p><h3 id="属性的简介表示法"><a href="#属性的简介表示法" class="headerlink" title="属性的简介表示法"></a>属性的简介表示法</h3><p>ES6允许直接写入变量名 与 函数名 来作为对象的属性 和 方法  这样使语法更加简介</p><pre><code>let x = 40function y () {    alert(1)}let obj = {x, y}console.log(obj)    // {x: 40, y: function}obj.y()             // 1function fn(x, y) {    return {x, y}}// 等同于function fn(x, y) {    return {x: x, y: y}}</code></pre><p>函数也同样<br>    let age = 18</p><pre><code>const Person = {    name: &apos;张三&apos;,    age,    // age: age    fn () {         // fn: function ....        console.log(this.age)    }}</code></pre><h3 id="Objuct-is-弥补-的不足-自动转换为数组类型-NAN都不相等-判断是否相等"><a href="#Objuct-is-弥补-的不足-自动转换为数组类型-NAN都不相等-判断是否相等" class="headerlink" title="Objuct.is() 弥补 == === 的不足  == 自动转换为数组类型  ===  NAN都不相等     判断是否相等"></a>Objuct.is() 弥补 == === 的不足  == 自动转换为数组类型  ===  NAN都不相等     判断是否相等</h3><pre><code>console.log(Object.is(1, &apos;1&apos;))         // false     // 同样是严格模式console.log(Object.is(1, 1))         // true console.log(Object.is({}, {}))         // false     let obj = {    name: [        {            c: &apos;aa&apos;        }    ],    b: 12}let obj1 = [...obj.name]console.log(obj.name == obj1)      // false</code></pre><h3 id="Object-assign-合并对象"><a href="#Object-assign-合并对象" class="headerlink" title="Object.assign()     合并对象"></a>Object.assign()     合并对象</h3><pre><code>// 注：assign 是浅拷贝let a = {a: &apos;a&apos;}let b = {b: &apos;b&apos;}           let obj = Object.assign(a, b)    // {a: &apos;a&apos;, b: &apos;b&apos;}// 如果有相同的键值，则后面的值会覆盖前面的let c = {b: &apos;c&apos;}   let obj = Object.assign(a, b, c)          // {a: &apos;a&apos;, b: &apos;c&apos;}let obj = Object.assign({}, a, b, c)console.log(a) 第一个参数为目标对象 指定为一个空,这样不会破坏原对象，同时，他只会拷贝原对象自身属性 ， 用处很多  不管是给对象新增属性 还是 方法 都很方便对象同样具有扩展运算符let obj = {a: 1, b: 2}let obj1 = {...obj}console.log(obj1)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructuring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript 6入门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-数组扩展</title>
    <link href="http://yoursite.com/2018/07/06/ES6-%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/06/ES6-数组扩展/</id>
    <published>2018-07-06T08:46:53.000Z</published>
    <updated>2018-07-09T11:46:40.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a><br><a id="more"></a></p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>基本用法</p><pre><code>扩展用算符是三个点，好比rest函数参数一样let arr = [1, 2, 3]console.log(...arr)     1 2 3console.log([...arr])     1 2 3</code></pre><p>使用扩展运算符传参</p><pre><code>function num(x, y, b) {     return x + y + b}let arr = [1,2,3]console.log(num(...arr))     // 6</code></pre><p>使用max求最大值</p><pre><code>console.log(Math.max(1,5,4,1,9,8))     // 9// 使用数组需要转console.log(Math.max([1, 5, 6, 4]))     // NAN// 使用扩展运算符更加简洁，方便console.log(Math.max(...[1,5,4,1,9,8]))     // 9</code></pre><p>push方法    数组的合并</p><pre><code>let [x, y] = [[1, 2, 3], [4, 5, 6]] 方法一console.log(x.concat(y))    // [1, 2, 3, 4, 5, 6]方法二x.push(...y)console.log(x)              // [1, 2, 3, 4, 5, 6]</code></pre><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><ol><li><p>复制数组</p><p> let arr1 = [1, 2];<br> let arr2 = arr1<br> arr2[0] = 2<br> console.log(arr1)   // [2, 2]<br> 上面代码中,只是多了一个指针，但是在内存当中都指向同一块空间，所以任意改变都会修改原数组</p><p> let arr1 = [1, 2];<br> arr2[0] = 2<br> // ES5解决<br> // let arr2 = arr1.concat()     // [1, 2]<br> // ES6解决<br> let arr2 = […arr1]            // [1, 2]<br> // Array.from()<br> let arr2 = Array.from(arr1)     // [1, 2]<br> arr2[0] = 2</p></li></ol><p>上述方法都可实现深拷贝</p><p>配合解构</p><pre><code>const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]let arr5 = [[1, 5], [2, 9]]...arr5     // [1, 5] [2, 9]</code></pre><h3 id="Array-from-用于将两种类数组转换为真正的数组"><a href="#Array-from-用于将两种类数组转换为真正的数组" class="headerlink" title="Array.from()    用于将两种类数组转换为真正的数组"></a>Array.from()    用于将两种类数组转换为真正的数组</h3><ol><li>有length的类数组     例如 document.getElementByTagName(‘div’)</li><li>可迭代的对象</li></ol><pre><code>let arrayLike = {&apos;0&apos;: &apos;a&apos;,&apos;1&apos;: &apos;b&apos;,&apos;2&apos;: &apos;c&apos;,length: 3}let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</code></pre><p>第二参数</p><pre><code>// Array.from  接受第二个参数  类似于 maplet arr = [1, 2, 3]console.log(Array.from(arr, (item) =&gt; item * item))     // [1, 4, 9]</code></pre><h3 id="Array-isArray-用于判断是否为一个真正的数组"><a href="#Array-isArray-用于判断是否为一个真正的数组" class="headerlink" title="Array.isArray()     用于判断是否为一个真正的数组"></a>Array.isArray()     用于判断是否为一个真正的数组</h3><pre><code>function isArray () {    return arguments}let fn = isArray(1, 5)console.log(Array.isArray(fn))                  // falseconsole.log(Array.isArray(Array.from(fn)))      // true</code></pre><h3 id="Array-of-用来创建数组并给其指定值"><a href="#Array-of-用来创建数组并给其指定值" class="headerlink" title="Array.of()  用来创建数组并给其指定值"></a>Array.of()  用来创建数组并给其指定值</h3><pre><code>一般声明数组console.log(new Array(5))      // [, , , ,]console.log(new Array(5, 2))             // [5, 2]console.log(new Array())                 // []console.log(Array.of(5))      // [5]console.log(Array.of(5, 2))             // [5, 2]console.log(new Array())                 // []使用其好处在于都进行了一个统一</code></pre><h3 id="Array-find-找到数组中包含某一项"><a href="#Array-find-找到数组中包含某一项" class="headerlink" title="Array.find() 找到数组中包含某一项"></a>Array.find() 找到数组中包含某一项</h3><p>[].findIndex()  用法与find一样   返回查找数组下标   这两个方法弥补了indexOf 方法的不足  都可以发现NAN</p><pre><code>console.log([1,8,5,6,9].find(x =&gt; x === 5))      // 5let arr = [    {        name: &apos;a&apos;    },    {        name: &apos;b&apos;    }]// 可接受三个参数  每一项, 下标, 原数组console.log(arr.find((x, index, arr) =&gt; {    console.log(index)    console.log(arr)    return x.name === &apos;b&apos;}))</code></pre><p>find方法只会返回一次，如果为空返回undefined</p><h3 id="Array-fill-装填，给数组指定默认值"><a href="#Array-fill-装填，给数组指定默认值" class="headerlink" title="Array.fill()    装填，给数组指定默认值"></a>Array.fill()    装填，给数组指定默认值</h3><pre><code>let arr = new Array(3).fill(&apos;&apos;)     // [&apos;&apos;, &apos;&apos;, &apos;&apos;]let arr = new Array(3).fill(5)     // [5, 5, 5]</code></pre><p>它有三个参数  参数 开始位置 结束位置</p><pre><code>console.log([1, 8, 6, 4].fill(2, 1, 2))     // [1, 2, 6, 4]console.log([1, 8, 6, 4].fill(2, 1, 8))     // [1, 2, 2, 2]</code></pre><h3 id="Array-entries-返回数组的键值"><a href="#Array-entries-返回数组的键值" class="headerlink" title="Array.entries()     返回数组的键值"></a>Array.entries()     返回数组的键值</h3><pre><code>let arr = [1, 2, 3, 5]for(let [index, item] of arr.entries()) {    console.log(&apos;value&apos; + item)    console.log(&apos;index&apos; + index)}使用了解构的方式进行赋值    [0, 1] [1, 2] [2, 3] [3, 5]</code></pre><h3 id="Array-keys-返回数组的键"><a href="#Array-keys-返回数组的键" class="headerlink" title="Array.keys()     返回数组的键"></a>Array.keys()     返回数组的键</h3><pre><code>let arr = [1, 2, 3, 8]for(let a of arr.keys()) {    console.log(&apos;index             &apos; + a)   // 下标}</code></pre><h3 id="includes-查找数组中是否包含某一项"><a href="#includes-查找数组中是否包含某一项" class="headerlink" title="includes()  查找数组中是否包含某一项"></a>includes()  查找数组中是否包含某一项</h3><pre><code>console.log([1, 2, 3].includes(2))      //true// 第二个参数 从该下标处开始查  如果大于当前数组长度 则 为默认值0  负数代表查找最后一个console.log([1, 2, 3].includes(2, 2))      //falseconsole.log([1, 2, 3].includes(3, -1))      //false</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructuring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript 6入门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-函数扩展</title>
    <link href="http://yoursite.com/2018/07/04/ES6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/04/ES6-函数扩展/</id>
    <published>2018-07-04T08:29:23.000Z</published>
    <updated>2018-07-06T08:45:49.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加油！<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><pre><code>function fn (x = 2) {    console.log(x)}fn(10)  // 10fn()    // 2</code></pre><p>无法使用Let 和 const再次进行声明，他们是唯一的</p><pre><code>function fn (x = 2) {    let x = 1    console.log(x)}fn(10)// 报错</code></pre><p>同样可是使用解构的方式</p><pre><code>function foo({x, y}) {    console.log(x, y());}foo({x: 1, y: () =&gt; 8})// x 1// y 8</code></pre><p>也可以指定默认值</p><pre><code>function foo({x = 50, y}) {    console.log(x, y());}foo({y: () =&gt; 8})// x 50// y 8</code></pre><h3 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h3><p>基本用法</p><pre><code>function fn(...arr) {    let sum = 0    arr.forEach(item =&gt; {        sum += item    })    return sum}console.log(fn(1, 2, 3))    // 6</code></pre><p>转换数组的方式</p><pre><code>// 方法1 function fn() {    return Array.prototype.slice.call(arguments)}// 方法2 rest function fn1(...arr) {    return arr}// 方法3 Array.from()function fn2() {    console.log(Array.from(arguments))}</code></pre><p>注意 rest后面不能再跟参数，否则会报错</p><pre><code>function fn(one, ...arr, num) {    // ...}fn(1,5,6,2)// 报错</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数使用为最多，他不仅语法简洁，降低代码量，同时更具有可读性</p><pre><code>let obj = {name: &apos;aa&apos;}let f = item =&gt; item.nameconsole.log(f(obj))     // aa</code></pre><p>如果没有参数 或者 有多个参数 用圆括号</p><pre><code>let a = () =&gt; 5let b = (num1, num2) =&gt; num1 + num2// 等同于let a = function () {    return 5}let b = function (num1, num2) {    return num1 + num2}</code></pre><p>只有代码为1行时不用写return </p><pre><code>let a = (item) =&gt; {    if (item.id === 1) {        return item    }}</code></pre><p>配合解构</p><pre><code>let obj = {    a: function () {        alert(88)    },    b: 10,    c: 16}let fn = ({a, b}) =&gt; a()    fn(obj) // 88let fn = ({c, b = 7}) =&gt; b + c  fn(obj) // 26</code></pre><p>默认值</p><pre><code>let obj = {    a: function () {        alert(88)    },    c: 16}let fn = ({c, b = 7}) =&gt; b + c  fn(obj)     // 23</code></pre><p>来看这个例子</p><pre><code>function Timer() {    this.s1 = 0;    this.s2 = 0;    // 箭头函数    setInterval(() =&gt; this.s1++, 1000);    // 普通函数    setInterval(function () {        this.s2++;        // alert(this.s2)    }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);   // 3setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);   // 0// 使用箭头函数 this会指向定义时的对象，所以s1会在3秒调用3次 为3  s2 的this指向了window的s2 并不存在 3秒内都是window的s2 在++ ，相加为NAN  但是是打印的当前构造函数内的s2，所以值为0</code></pre><p>所以下面为被编译的ES5</p><pre><code>let a = () =&gt; {    setTimeout(() =&gt; {        console.log(this.id)    }, 2000);}let a = function () {    var _this = this    setTimeout(() =&gt; {        console.log(_this.id)    }, 2000);}</code></pre><h3 id="箭头函数总结"><a href="#箭头函数总结" class="headerlink" title="箭头函数总结"></a>箭头函数总结</h3><pre><code>1. 代码简洁，更具有可读性2. this指向定义时的对象，并不是调用时的3. 因为本身并没有this,无法作为构造函数，无法使用New4. 没有arguments对象，不过可以使用rest   ...arr</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加油！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-字符串扩展</title>
    <link href="http://yoursite.com/2018/07/04/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/07/04/ES6-字符串扩展/</id>
    <published>2018-07-04T06:23:21.000Z</published>
    <updated>2018-07-04T08:47:17.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加油！<br><a id="more"></a></p><p>遵循二八，只写常用的</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>在ES5中 查找字符串是否存在使用indexOf 大于-1则存在，ES6出了个方法，includes,改方法返回boolean</p><pre><code>let str = &apos;卫栖梧dqweqwe4152&apos;console.log(str.includes(&apos;5&apos;))      // trueconsole.log(str.includes(&apos;10&apos;))      // falseconsole.log(str.includes(&apos;dqwe&apos;))      // true</code></pre><p>startsWith 第一个是否为某一项<br>endsWith 最后一个是否为某一项</p><pre><code>let str = &apos;卫栖梧dqweqwe4152&apos;console.log(str.startsWith(&apos;5&apos;))    // falseconsole.log(str.endsWith(&apos;2&apos;))      // true</code></pre><p>repeat 重复字符串</p><pre><code>// console.log(&apos;aaa&apos;.repeat(8))         // aaaaaaaaaaaaaaaaaaaaaaaa</code></pre><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>先看常规拼接字符串</p><pre><code>let a = &apos;谁最帅&apos;let b = &apos;当然是我&apos;console.log(&apos;现在&apos; + a + &apos;,&apos; + b + &apos;啦&apos;)    //现在谁最帅,当然是我啦</code></pre><p>ES6 字符串模板<br>    console.log(<code>现在${a},${b}啦</code>)      //现在谁最帅,当然是我啦</p><p>这样的写法更具有可读性，更加简洁，同时字符串模板支持简单的运算，可写函数返回，还支持隔行</p><pre><code>let a = &apos;拼接&apos;let b = &apos;字符串&apos;function name () {    return &apos;我是函数&apos;}let c = `我在${a}${b}    ${name()}`console.log(c)// 我在拼接字符串        我是函数</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加油！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6-解构赋值</title>
    <link href="http://yoursite.com/2018/06/27/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2018/06/27/ES6-解构赋值/</id>
    <published>2018-06-27T11:49:59.000Z</published>
    <updated>2018-07-04T08:09:01.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>只想每天学习新的总结那么一点，不想原地踏步<br><a id="more"></a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6入门</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>解构分为数组解构、对象解构、字符串解构、函数参数解构,还有些不常用的，就不说了</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>通常我们进行赋值</p><pre><code>let a = &apos;a&apos;let b = &apos;b&apos;let c = &apos;c&apos;</code></pre><p>ES6提供数组解构为</p><pre><code>let [a, b, c] = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]a // &apos;a&apos;b // &apos;b&apos;c // &apos;c&apos;</code></pre><p>从上述可以看得出来，数组组件主要针对位置来进行赋值</p><p>也可写成这样<br>    let [a, [b, c]] = [10, [20, 30]]<br>    a // 10<br>    b // 20<br>    c // 30</p><p>如果对应位置没有对应值，则为undefined<br>    let [a, [b, c]] = [10, [, 30]]<br>    a // 10<br>    b // undefined<br>    c // 30</p><p>也可初始化值</p><pre><code>let [a=5, [b=3, c]] = [10, [, 30]]a // 10b // 3c // 30</code></pre><p>// 需要注意！只有当等于undefined时才会被赋值默认值，注意是全等，严格模式</p><pre><code>let [a=5, [b=3, c]] = [10, [null, 30]]a // 10b // nullc // 30</code></pre><p>赋值必须是可迭代的(iterator)</p><pre><code>let [a=5,b] = 1// 报错</code></pre><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>这样写会抛出错误<br>    let {a:10,b:10} = {a:20,b: 40}</p><p>原因，对象解构与数组解构不同，数组解构是通过对应位置，而对象解构则通过 等号 左边的键 去查找 右侧的键值，在找到后，赋值给右侧的值</p><pre><code>let {a: b,c: d} = {a: 50, c: 90}a //undefinedb // 50c // undefinedd // 90</code></pre><p>看到这应该明白了  也就是收  通过a 到 右边去找到对应的值，然后从新赋值给b  这就是区别</p><p>设定默认值</p><pre><code>let {a: b=10,c: d=4} = {a: undefined, c: undefined}b // 10d // 4</code></pre><h3 id="函数参数解构"><a href="#函数参数解构" class="headerlink" title="函数参数解构"></a>函数参数解构</h3><pre><code>function a () {    alert(&apos;a&apos;)}function b () {    alert(&apos;b&apos;)}function move ([a, b]) {    a()}move([a, b])</code></pre><p>总之,把数组解构 和 对象解构 理解了 其他都差不多</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;只想每天学习新的总结那么一点，不想原地踏步&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue，公共tab跳转不同路由页面样式切换</title>
    <link href="http://yoursite.com/2018/06/08/Vue%EF%BC%8C%E5%85%AC%E5%85%B1tab%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E8%B7%AF%E7%94%B1%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/06/08/Vue，公共tab跳转不同路由页面样式切换/</id>
    <published>2018-06-08T08:53:27.000Z</published>
    <updated>2018-06-08T11:35:27.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>先有一个公共tab组件用来分别跳转不同路由的页面</p><p>例<br>    a 公共组件<br>    b 点击跳转页面<br>    c 点击跳转页面</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>两种方法解决选中样式问题</p><ol><li>router-link标签 （推荐）<br><router-link to="/a" active-class="active"><br><router-link to="/b" active-class="active"></router-link></router-link></li></ol><p>active为选中的样式</p><ol start="2"><li>通过路由当前参数来进行判断</li></ol><p>data () {<br>    return {<br>        active: this.$route.query.index || 0<br>    }<br>}</p><p>在跳转时传递不同参数  选项卡通过当前active来进行判断，实现样式的切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;p&gt;先有一个公共tab组件用来分别跳转不同路由的页面&lt;/p&gt;
&lt;p&gt;例&lt;br&gt;    a 公共组件&lt;br&gt;    b 点击跳转页面&lt;br&gt;   
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>v-html</title>
    <link href="http://yoursite.com/2018/06/07/v-html/"/>
    <id>http://yoursite.com/2018/06/07/v-html/</id>
    <published>2018-06-07T07:50:58.000Z</published>
    <updated>2018-06-08T08:51:31.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>v-html 渲染出来的标签无法修改样式</p><p>结构</p><pre><code>&lt;div class=&quot;wrap&quot;&gt;    &lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>解决</p><pre><code>.wrap &gt;&gt;&gt;div{    //.....}.wrap &gt;&gt;&gt;span{    //.....}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小技巧&quot;&gt;&lt;a href=&quot;#小技巧&quot; class=&quot;headerlink&quot; title=&quot;小技巧&quot;&gt;&lt;/a&gt;小技巧&lt;/h3&gt;&lt;p&gt;v-html 渲染出来的标签无法修改样式&lt;/p&gt;
&lt;p&gt;结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="http://yoursite.com/2018/05/25/vuex/"/>
    <id>http://yoursite.com/2018/05/25/vuex/</id>
    <published>2018-05-25T11:45:26.000Z</published>
    <updated>2018-06-07T07:49:54.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vuex,个人理解为一个提供全局公用的属性及方法，是中大型开发项目架构中不可缺少的一部分，他的设计及使用都很方便，便于协同开发。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install --save-dev vuex</code></pre><p>安装至package.json中开发依赖</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>main.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import store from &apos;./store/index&apos;Vue.use(Vuex)               // 全局配置new Vue({    el: &apos;#app&apos;,    router,    store,                  // 导入全局    render: h =&gt; h(App)})</code></pre><p>store/index.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)               // 全局配置let store = {    state: {        ....    },    getters: {        ....    },    mutations: {        ....    },    actions: {        ....    }}//导出storeexport default store</code></pre><p>以上是store的基本配置</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>存储数据的，任何属性的定义都在里</p><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以理解为Vue的计算属性，假设有这样一个需求  需要让你过滤出小于25的数</p><pre><code>let sotre = {    state: {        data: [10, 50, 10, 40]    }}当然聪明你的肯定在组件中轻易的就可以写出来，但是如果换一个页面的话 是不是还要在写一遍？如果10， 20个的话 是不是就吐啦？？，所以getters就来解决这种问题</code></pre><p>store/index.js</p><pre><code>let sotre = {    state: {        data: [10, 50, 10, 40]    },    getters: {        filterData (state) {            return state.data.filter(item =&gt; item &lt; 25)        }    }}</code></pre><p>index.vue</p><pre><code>mounted () {    // 获取已过滤出的数据    let data = this.$store.getters.filterData}</code></pre><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>想要修改state 中的数据 ，只能mutations来进行修改，并且它是同步的，稍后会讲到action（异步），这种模式能够更加清晰的知道你的数据是什么来进行改变的，具有可读性和可维护性</p><p>store/index.js</p><pre><code>state: {    name: &apos;张三&apos;},getters: {    filterData (state) {        return state.data.filter(item =&gt; item &lt; 25)    }},mutations: {    changeName1 (state) {        state.name = &apos;李四&apos;    },    changeName2 (state, people) {        state.name = people.name    }}</code></pre><p>index.vue</p><pre><code>// 调用1html{{ this.$store.state.name }}  // 李四mounted () {    this.$store.commit(&apos;changeData&apos;)}// 调用2html{{ this.$store.state.name }}  // aamounted () {    // 传值方式1    this.$store.commit(&apos;changeData&apos;, {        name: &apos;aa&apos;    })    // 传值方式2    this.$store.commit({        type: &apos;changeData&apos;,        name: &apos;aa&apos;    })}</code></pre><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>前面说到了 mutations 是使用同步来进行解决的，异步的话使用action来处理，为什么呢？ 首先，得按照人家的规矩的来不是？ 其次，还是因为追踪数据，如果mutations使用了异步，无法追踪到数据改变的纪录，同时有时会导致错误，无法进行赋值，前面说了只能通过mutations来进行改变，所以action所做的就是调用mutations内的函数，通过实参传递过去。</p><p>store/index.js</p><pre><code>state: {    arr: &apos;张三&apos;,    userInfo: []},getters: {    filterData (state) {        return state.data.filter(item =&gt; item &lt; 25)    },    userInfo: state =&gt; state.userInfo},mutations: {    changeArr (state) {        state.arr = data      },    changeArr1 (state, data) {        state.arr = data.data    }},action: {    asynChangeName ({commit}) {         // es6函数参数解构        commit(&apos;changeName&apos;)            // 基本调用    },    asynChangeName1 ({commit}) {         // es6函数参数解构        let data = [            {                name: &apos;加油&apos;,                age: 10            }, {                name: &apos;你是&apos;,                age: 15            }, {                name: &apos;最棒的&apos;,                age: 20            },        ]        setTimeOut(() =&gt; {            commit(&apos;changeName&apos;, data)      // 异步通过这种方式来进行赋值        }, 200)    },    asynChangeName2 ({commit}) {        new Promise((resolve, rejuct) =&gt; {            let random = Math.random()            if (random &gt; 0.5) {                resolve(random)            } else {                rejuct(&apos;小于0.5哦&apos;)            }        })    },    getUserInfo () {    }}</code></pre><p>index.vue</p><pre><code>mounted () {    let num = this.$store.dispatch(&apos;asynChangeName2&apos;)    num.then((resolve) =&gt; {        alert(resolve)    })}</code></pre><p>main.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import Router from &quot;vue-router&quot;import store from &apos;./store/index&apos;Vue.use(Vuex)               // 全局配置Vue.use(Router)             // 全局路由Router.beforeEach((to, from, next) =&gt; {    if (store.state.userInfo.length === 0) {        next({            path: &apos;/&apos;        })    }    next()})new Vue({    el: &apos;#app&apos;,    router,    store,                  // 导入全局    render: h =&gt; h(App)})一个简单的路由守卫拦截的登录功能，同样具有拦截效果的是axios，具体在后面我会更新</code></pre><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>当你的项目越来越庞大，store会变的臃肿，所以你需要继续把它拆分出来，更具有可维护性</p><p>store/index.js</p><pre><code>import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import User from &apos;./store/common/user.js&apos;import Other from &apos;./store/common/other.js&apos;Vue.use(Vuex)export default new Vuex.Store({    modules: {        User,        Other    }})</code></pre><p>store/common/user.js</p><pre><code>let User = {    state: {        ...    },    mutations: {    }}export default User</code></pre><p>store/common/other.js</p><pre><code>let Other = {    state: {        ...    },    mutations: {    }}export default Other</code></pre><p>以上是个人理解Vuex，让我们继续努力加油吧！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vuex,个人理解为一个提供全局公用的属性及方法，是中大型开发项目架构中不可缺少的一部分，他的设计及使用都很方便，便于协同开发。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gulp</title>
    <link href="http://yoursite.com/2018/05/21/gulp/"/>
    <id>http://yoursite.com/2018/05/21/gulp/</id>
    <published>2018-05-21T11:19:16.000Z</published>
    <updated>2018-08-09T01:25:43.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在被大老大一顿嘲讽后，恶补了一下gulp,看了看  真的很简单呀<br>    gulp拥有简洁的API，使用者能够轻易上手，Gulp是一个自动化构建工具，具有强大的插件，只要搭配合适，能够大大提高我们工作中开发的效率。gulp更加强调的是开发流程，通过taskAPI可以定义符合自己的流程。<br>    webpack主要是模块化的规范，更加强调模块化，把各种文件看成模块，用过loader,最终打包为css/js/html/图片等</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">前端构建工具gulpjs的使用介绍及技巧 - 无双 - 博客园</a></p><h3 id="gulp-工作模式"><a href="#gulp-工作模式" class="headerlink" title="gulp 工作模式"></a>gulp 工作模式</h3><p>gulp是基于nodejs的stream流的概念，通过pipe()来导入到你想要让他去的地方，是一个抽象的概念，比如gulp.src获取到相关内容，通过.pipe导入到插件中，在通过插件处理后，在通过pipe导入，通过gulp.dest来指定到相应位置</p><h3 id="四大API"><a href="#四大API" class="headerlink" title="四大API"></a>四大API</h3><p><strong>一 gulp.src(glob, [, option])</strong><br>    该方法主要获取到你的文件源，通过这个路径来找到对应的文件</p><ol><li>glob类似于正则表达式，主要通过这个来找到文件</li><li>option 可选参数，通常不需要用到</li></ol><p>主要讲讲glob</p><pre><code>*                   // 匹配0个或多个字符，但不会匹配到路径分隔符**                  // 匹配所有字符，包括路径分隔符?                   // 匹配文件中的一个字符，不包含路径分隔符[...]               // 匹配方括号中的所有路径，如果出现^或者!，则匹配时不会去找相应文件</code></pre><p>例子：</p><pre><code>*                   // 能匹配a.js/b.css/d.html/aa    但不包含b/a.js*.*                 // 能匹配.后缀名所有的文件**                  // 能匹配所有文件，包含b/a.js c/d.css*/*/*.*             // 能匹配a/b/a.js / c/d/b.css[&apos;*/abc/*.js&apos;]      // 匹配c/abc/e.js / v/abc/ss.js[&apos;!c/abc/*.js&apos;, &apos;c/abc/*.css&apos;]     // 不会匹配c/abc/下的所有js</code></pre><p><strong>二 gulp.dest(path, [, option])</strong><br>该方法主要把经过<strong>插件处理</strong> 或 <strong>gulp.src命令</strong>中的stream流写入到指定的文件路径</p><ol><li>path指定路径</li><li>option 可选参数，通常不需要用到</li></ol><p>例子：<br>    gulp.task(‘default’, function () {<br>        gulp.src(‘src/css/*.css’)<br>            .pipe(gulp.dest(‘dist/css’))<br>    })</p><p>task命令稍后会讲，以上功能只是一个简单的复制功能，就是找到src/css下所有css文件，通过dest命令写入dist/css文件中</p><p><strong>三 gulp.task(name, [, deps], fn)</strong><br>task方法用于定义命令</p><ol><li>name为命令的名称</li><li>deps依赖任务的队列，如果你对执行顺序有要求，以数组的方式依次写入顺序即可</li><li>fn业务逻辑</li></ol><p>创建一个依赖队列的任务执行<br>gulp.task(‘test’, [‘a’, ‘b’, ‘c’, ‘d’], function () {<br>    // …..<br>})</p><p>这个命令也没啥好讲的，不过要记住你得定义一个空的命令用来执行你定义的task命令就好</p><p>异步的三种解决方法，暂时还没有遇到异步的，等遇到了在进行补充！</p><p><strong>四 gulp.watch(glob, [, deps], [tasks])</strong><br>watch用于监听某个路径下的文件，当发生改变后会进行触发</p><ol><li>glob用法与gulp.src相同</li><li>deps可选参数，通常不需要用到</li><li>tasks是一个数组，里面是你task定义的命令，当监听被触发后，会执行定义在这里的任务</li></ol><p>gulp.task(‘copyCss’, function () {<br>    gulp.src(‘src/<em>/</em>.css’)<br>        .pipe(gulp.dest(‘dist/css))<br>})<br>gulp.task(‘dev’, function () {<br>    gulp.watch(‘src/<em>/</em>.css’, [‘copyCss’])<br>})</p><p>在package.json中 scripts中 写入 “dev”: “gulp dev” 命令</p><pre><code>npm run dev         启动命令</code></pre><p>当修改src下的css文件后，会执行copyCss命令，你在dist文件下的css就会实时更新了</p><h3 id="gulp常用插件"><a href="#gulp常用插件" class="headerlink" title="gulp常用插件"></a>gulp常用插件</h3><p><strong>gulp-load-plugins  自动载入插件</strong></p><p>安装：<br>        cnpm install --save-dev gulp-load-plugins       </p><p>功能：<br>    该插件主要解决繁多的命名空间和代码整洁度<br>    例子：<br>    var gulp = require(‘gulp’),<br>    //一些gulp插件,abcd这些命名只是用来举个例子<br>    a = require(‘gulp-a’),<br>    b = require(‘gulp-b’),<br>    c = require(‘gulp-c’),<br>    d = require(‘gulp-d’),<br>    e = require(‘gulp-e’),<br>    f = require(‘gulp-f’),<br>    g = require(‘gulp-g’)</p><p>用法：<br>    var gulp = require(‘gulp’),<br>        plugins = require(‘gulp-load-plugins’)()    //调用下方法</p><pre><code>gulp.task(&apos;default&apos;, function () {    // 例如你有个js压缩插件    gulp.src(&apos;src/js/*.js&apos;)        // gulp-uglify      //调用时值仅需要uglify即可，如果后面还有中划线，以驼峰的方式 例:gulp-minify-css  plugins.minifyCss        .pipe(plugins.uglify())        .pipe(gulp.dest(&apos;dist/js&apos;))})</code></pre><p><strong>browserSnyc  热更新</strong></p><p>安装browserSync</p><p>使用它只需要记住 在每个执行命令中需要调用一次reload方法就好，具体先看下文档~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在被大老大一顿嘲讽后，恶补了一下gulp,看了看  真的很简单呀&lt;br&gt;    gulp拥有简洁的API，使用者能够轻易上手，Gulp是一个自动化构建工具，具有强大的插件，只要搭配合适，能够大大提高我们工作中开发的效率。gulp更加强调的是开发流程，通过taskAPI可以定义符合自己的流程。&lt;br&gt;    webpack主要是模块化的规范，更加强调模块化，把各种文件看成模块，用过loader,最终打包为css/js/html/图片等&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我要对陈晨大声的说:我~~爱~~~你！</title>
    <link href="http://yoursite.com/2018/05/19/%E6%88%91%E8%A6%81%E5%AF%B9%E9%99%88%E6%99%A8%E5%A4%A7%E5%A3%B0%E7%9A%84%E8%AF%B4-%E6%88%91-%E7%88%B1-%E4%BD%A0%EF%BC%81/"/>
    <id>http://yoursite.com/2018/05/19/我要对陈晨大声的说-我-爱-你！/</id>
    <published>2018-05-19T14:58:20.000Z</published>
    <updated>2018-05-19T16:01:54.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相信我！"><a href="#相信我！" class="headerlink" title="相信我！"></a>相信我！</h3><a id="more"></a><h3 id="第一次见面"><a href="#第一次见面" class="headerlink" title="第一次见面"></a>第一次见面</h3><p>刚搬来的时候是我们第一次见面，看到你的第一眼心想：能跟这么漂亮的女孩子合租真好。</p><h3 id="第一次说话"><a href="#第一次说话" class="headerlink" title="第一次说话"></a>第一次说话</h3><p>嗯，大半夜收拾屋~，心想，这谁呀，但半夜走来走去的，还收拾屋，结果出门看到了你，就说了句大半夜还收拾屋呀，然后你害羞的说 嗯，收拾收拾，当时心想 好勤快呀！</p><h3 id="第一次一起上班"><a href="#第一次一起上班" class="headerlink" title="第一次一起上班"></a>第一次一起上班</h3><p>刚准备走呢，就看到你一个人出门，就赶紧收拾收拾，然后跟你一块出门，也是从那开始，我的生活中有了你<br><img src="/static/0519.jpg" alt="img"></p><p>然后我就知道你的出门时间，每次都会早起，然后收拾好等你，还必须要装作碰巧的样子，有一次你出门比较早，没等到，然后我第二天就又早起，必须得和你一块走！</p><h3 id="你傻傻的样子最可爱"><a href="#你傻傻的样子最可爱" class="headerlink" title="你傻傻的样子最可爱"></a>你傻傻的样子最可爱</h3><p>还记得有一次你收拾屋，美君还没回来，然后你收拾的可干净了，跟美君发微信视频，说看，这是的收拾的屋，可干净了，就等你回来了，当时我感觉你可开心可有信心了，我都想去看一看…</p><h3 id="你是我的"><a href="#你是我的" class="headerlink" title="你是我的"></a>你是我的</h3><p>然后，我就越来越喜欢你，喜欢你傻傻的很纯洁的笑，喜欢你的勤奋，喜欢你说话逗别人开心，总之，跟你接触的这段时间，你都深深的把我吸引到了，必须得追你~！</p><p>但是那天，像往常一样等你一块上班，有个男的从你卧室出来，然后你跟在他后面，当时我就心凉了一半，心想应该不是我想的那样吧，想了想，刚好你回来拿伞，在电梯门口碰见了，就问你那男的，你说是你男朋友，然后我就心全凉了，特别不开心，不过我在你们后面看到，好像不是很亲密的样子，应该没处多久，但是我是一个有原则的人，绝对不会去挖墙脚干这种事情，总之想了想，算了吧。</p><p>然后你在朋友圈发了一条说说，说你也该找一个了，当时我就感觉要上天了，必须得抓住这个机会</p><p><img src="/static/05192.jpg" alt="img"></p><p>刚好到了五一，就想着必须得下手了，然后就约你出来玩，你也很配合的来了，当时我就知道我要献出第一次了。。。哈哈哈，第一次表白，本来一直想说，但是一直缺少勇气，怕你会拒绝，但是~上了大摆锤后，是大摆锤给我的勇气，在坐下的那一瞬间我就知道我必须说了，做我的女朋友吧，说完我感觉好舒服，终于做了一件让自己感觉满意的事情，然后看你害羞的…..Emmmmmm，那一天真的好开心</p><p><img src="/static/timg.gif" alt="img"></p><p>从五一过后，我就一直在关注你，可能我也比较心急，你也说心急吃不了热豆腐，那不是怕真的错过了呗，我可是一个追求完美的人，不会轻易说认输，所以，你必须得是我的</p><h3 id="感动"><a href="#感动" class="headerlink" title="感动"></a>感动</h3><p>让我最感动的是  我说我失眠，然后你就说陪我跑步，一直坚持到现在，然后真的很有效果，有你真好！</p><h3 id="05月10日-我要你！"><a href="#05月10日-我要你！" class="headerlink" title="05月10日 我要你！"></a>05月10日 我要你！</h3><p>这一天，是我们第一次牵手，原谅我你当时问我 我没有说出来，因为当时真的懵了…</p><p><img src="/static/05193.jpg" alt="img"></p><p>你的生日是04-17 我会记住的，可能我有时候大脑会短路，多多包涵~~哈哈</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>我有时候说你胖了什么的 你别在意，我下次也不会说啦，怪我，不过我会尽量缩短我在单位的工作时间早点回来陪你跑步，直到让你对自己身材满意为止，我会陪着你的！！！</p><p>陈晨，我不是一个爱说以后的人，因为说以后真的是一个笑话，我只能说，当下我会好好的爱你，对你加倍的好，也会包容你的小脾气，每周都会给你做好吃的，带你去你想去的地方，我会好好努力，挣钱养你和我妈~相信我，当然我可能也会有点小脾气，也有很多的缺点，但是你一定要及时的提出来啦，你提的我都为了咱们去改！相信我！</p><p>最后，今天是个特殊的日子，我要大声的说</p><h1 id="陈晨，我爱-你！！！！让我们一直这样的幸福下去！"><a href="#陈晨，我爱-你！！！！让我们一直这样的幸福下去！" class="headerlink" title="陈晨，我爱~你！！！！让我们一直这样的幸福下去！"></a>陈晨，我<del>爱</del>~你！！！！让我们一直这样的幸福下去！</h1><p><img src="/static/langman.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相信我！&quot;&gt;&lt;a href=&quot;#相信我！&quot; class=&quot;headerlink&quot; title=&quot;相信我！&quot;&gt;&lt;/a&gt;相信我！&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node环境变量配置</title>
    <link href="http://yoursite.com/2018/05/16/node%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/16/node环境变量配置/</id>
    <published>2018-05-16T13:40:23.000Z</published>
    <updated>2018-05-17T01:50:00.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个环境变量实在是有点坑，前面倒腾了几次，还是有问题，现在这个问题终于解决了，我来阐述下我的配置及踩过的坑</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><pre><code>vue -V 不是内部命令node -v 不是内部命令npm -v 不是内部命令等</code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>出现以上场景都是因为你的npm路径有问题，所以导致不是命令，接下来将会配置npm</p><pre><code>1. 指定npm全局路径 </code></pre><p>我会在E盘创建nodejs文件目录，在下面分别创建node_global和node_cache文件夹</p><pre><code>2. 命令npm config set prefix &quot;d:\nodejs\node_global&quot;npm config set prefix &quot;d:\nodejs\node_cache&quot;</code></pre><p>以上命令指定npm的路径为刚刚创建的文件路径<br>    3.配置环境变量<br>环境变量分为系统变量和用户变量<br>    系统变量中新建变量名：NODE_PATH，变量值：D:\nodejs\node_global\node_modules<br>    路径还是刚刚创建时的路径<br>    用户变量中的PATH中添加：D:\nodejs\node_global</p><p>一定记得 不要在系统变量中的PATH去写，我之前就是踩的这个深坑，怎么找都找不出来，加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个环境变量实在是有点坑，前面倒腾了几次，还是有问题，现在这个问题终于解决了，我来阐述下我的配置及踩过的坑&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
